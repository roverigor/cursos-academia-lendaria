# 07.4 - Multi-tenant: Isolando Dados de Clientes

**M√≥dulo:** 7 - Seguran√ßa (RLS) Sem Paranoia
**Dura√ß√£o:** 15 minutos
**Objetivo:** Implementar isolamento de dados multi-tenant com RLS
**Bloom Level:** Apply
**Fidelity Target:** 93%+ (Jos√© Amorim voice)

---

## üéØ O Que Voc√™ Vai Aprender

Ao final desta aula, voc√™ vai saber:
- ‚úÖ O que √© multi-tenant (SaaS com m√∫ltiplos clientes)
- ‚úÖ Diferen√ßa entre tenant e user
- ‚úÖ Como armazenar tenant_id no JWT
- ‚úÖ Criar policies por tenant_id
- ‚úÖ Performance tuning com indexes

---

## üî• GANCHO EMOCIONAL (Camada 1)

Te fa√ßo uma pergunta:

**"SaaS = m√∫ltiplos clientes compartilham o mesmo banco. Como isolar dados de cada cliente?"**

Essa √© a pergunta que TODO dev de SaaS enfrenta.

---

Porque o desafio √©:

**Cen√°rio:**
- Voc√™ cria um CRM
- Empresa A usa seu CRM
- Empresa B usa seu CRM
- Ambas compartilham o MESMO banco de dados

**Problema:**
- Como garantir que Empresa A N√ÉO v√™ dados da Empresa B?
- Como garantir isolamento TOTAL?

---

**Resposta: Multi-tenant RLS**

---

Quando eu vi isso pela primeira vez, achei complicado.

Mas depois percebi:

**√â LITERALMENTE a mesma coisa que user_id.**

S√≥ que agora voc√™ filtra por `tenant_id` em vez de `user_id`.

---

**Multi-tenant = forma profissional de rodar SaaS.**

E RLS torna isso TRIVIAL.

---

## üè† MET√ÅFORA VISUAL (Camada 2)

Imagina um edif√≠cio com m√∫ltiplos apartamentos.

**Cada apartamento = 1 tenant (cliente)**

**Cada inquilino = 1 user (usu√°rio dentro do tenant)**

---

**Sem multi-tenant (1 banco por cliente):**
- Cada cliente tem um pr√©dio INTEIRO pra ele
- Empresa A = Pr√©dio A
- Empresa B = Pr√©dio B
- Custo: ALTO (manuten√ß√£o de N pr√©dios)

**Com multi-tenant (1 banco compartilhado):**
- Todos os clientes dividem o MESMO pr√©dio
- Empresa A = Apartamento 1
- Empresa B = Apartamento 2
- Custo: BAIXO (1 pr√©dio, N apartamentos)

---

**Mas como garantir que inquilino do Apt 1 n√£o entra no Apt 2?**

**Resposta: Paredes + portas trancadas**

Isso √© RLS com `tenant_id`.

---

Outra met√°fora:

Imagina um hospital.

**Cada hospital tem m√∫ltiplos M√âDICOS.**

**Cada m√©dico tem m√∫ltiplos PACIENTES.**

**Regra:** M√©dico A n√£o pode ver pacientes do M√©dico B.

**Solu√ß√£o:**
- Cada m√©dico = 1 tenant
- Cada paciente tem `medico_id` (tenant_id)
- RLS filtra automaticamente

---

## üí° FUNDAMENTO CONCEITUAL (Camada 3)

Deixa eu descomplicar:

### Tenant vs User

**User = Usu√°rio individual**
- Jo√£o, Maria, Pedro

**Tenant = Organiza√ß√£o/Cliente**
- Empresa A, Empresa B, Empresa C

**Rela√ß√£o:**
- 1 Tenant pode ter N Users
- Empresa A tem Jo√£o, Maria (2 users)
- Empresa B tem Pedro, Lucas (2 users)

---

**Estrutura:**

```
Tenants
| id  | nome        |
|-----|-------------|
| 1   | Empresa A   |
| 2   | Empresa B   |

Users
| id  | tenant_id | nome  |
|-----|-----------|-------|
| abc | 1         | Jo√£o  |
| def | 1         | Maria |
| ghi | 2         | Pedro |

Clientes (dados do tenant)
| id | tenant_id | nome_cliente |
|----|-----------|--------------|
| 1  | 1         | Cliente X    | ‚Üê Empresa A
| 2  | 1         | Cliente Y    | ‚Üê Empresa A
| 3  | 2         | Cliente Z    | ‚Üê Empresa B
```

---

### tenant_id em Metadata

**Como saber qual tenant o user pertence?**

**Op√ß√£o 1: Coluna na tabela users**
```sql
ALTER TABLE auth.users ADD COLUMN tenant_id UUID;
```

**Op√ß√£o 2: app_metadata (Supabase)**
```json
{
  "user_id": "abc",
  "app_metadata": {
    "tenant_id": "tenant-1"
  }
}
```

---

### Filtrar por tenant_id em Policies

**Policy padr√£o:**
```sql
CREATE POLICY "Users see own tenant data"
ON clientes
FOR SELECT
USING (
  tenant_id = (
    SELECT tenant_id
    FROM auth.users
    WHERE id = auth.uid()
  )
);
```

**Tradu√ß√£o:** "Retorne clientes onde tenant_id = tenant do usu√°rio logado"

---

**Com app_metadata:**
```sql
CREATE POLICY "Users see own tenant data"
ON clientes
FOR SELECT
USING (
  tenant_id::TEXT = (auth.jwt()->>'tenant_id')
);
```

**Tradu√ß√£o:** "Extraia tenant_id do JWT e compare"

---

### Armazenar Tenant no app_metadata

**No signup:**
```js
const { data, error } = await supabase.auth.signUp({
  email: 'joao@empresa-a.com',
  password: 'senha123',
  options: {
    data: {
      tenant_id: 'tenant-1' // ‚Üê Metadata
    }
  }
});
```

**No JWT:**
```json
{
  "sub": "user-abc",
  "email": "joao@empresa-a.com",
  "app_metadata": {
    "tenant_id": "tenant-1"
  }
}
```

---

## ‚ö° APLICA√á√ÉO PR√ÅTICA (Camada 4)

### Exemplo 1: Tabela com tenant_id

**Estrutura:**
```sql
-- Tenants
CREATE TABLE tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT
);

-- Users (com tenant_id)
ALTER TABLE auth.users ADD COLUMN tenant_id UUID REFERENCES tenants(id);

-- Clientes (dados do tenant)
CREATE TABLE clientes (
  id BIGSERIAL PRIMARY KEY,
  tenant_id UUID REFERENCES tenants(id),
  nome TEXT,
  email TEXT
);
```

---

**Inserir dados:**
```sql
-- Tenants
INSERT INTO tenants (id, nome) VALUES
  ('tenant-1', 'Empresa A'),
  ('tenant-2', 'Empresa B');

-- Users (simplificado)
-- No signup real, Supabase cria automaticamente
-- Aqui s√≥ pra ilustra√ß√£o
INSERT INTO auth.users (id, tenant_id, email) VALUES
  ('user-abc', 'tenant-1', 'joao@empresa-a.com'),
  ('user-def', 'tenant-2', 'pedro@empresa-b.com');

-- Clientes
INSERT INTO clientes (tenant_id, nome) VALUES
  ('tenant-1', 'Cliente X'),
  ('tenant-1', 'Cliente Y'),
  ('tenant-2', 'Cliente Z');
```

---

### Exemplo 2: Policy que Filtra por tenant_id

```sql
ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users see own tenant clients"
ON clientes
FOR SELECT
USING (
  tenant_id = (
    SELECT tenant_id
    FROM auth.users
    WHERE id = auth.uid()
  )
);
```

---

**Teste:**

Jo√£o (user-abc, tenant-1) faz:
```sql
SELECT * FROM clientes;
```

**Retorna:**
```
| id | tenant_id | nome      |
|----|-----------|-----------|
| 1  | tenant-1  | Cliente X | ‚úÖ
| 2  | tenant-1  | Cliente Y | ‚úÖ
```

**N√ÉO retorna Cliente Z (tenant-2).**

---

Pedro (user-def, tenant-2) faz:
```sql
SELECT * FROM clientes;
```

**Retorna:**
```
| id | tenant_id | nome      |
|----|-----------|-----------|
| 3  | tenant-2  | Cliente Z | ‚úÖ
```

**N√ÉO retorna Cliente X e Y (tenant-1).**

---

### Exemplo 3: M√∫ltiplas Organiza√ß√µes (Multi-org)

**Cen√°rio:** SaaS onde user pode pertencer a M√öLTIPLAS organiza√ß√µes.

**Estrutura:**
```sql
CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT
);

CREATE TABLE user_organizations (
  user_id UUID REFERENCES auth.users(id),
  organization_id UUID REFERENCES organizations(id),
  PRIMARY KEY (user_id, organization_id)
);

CREATE TABLE projetos (
  id BIGSERIAL PRIMARY KEY,
  organization_id UUID REFERENCES organizations(id),
  nome TEXT
);
```

---

**Policy:**
```sql
ALTER TABLE projetos ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users see org projects"
ON projetos
FOR SELECT
USING (
  organization_id IN (
    SELECT organization_id
    FROM user_organizations
    WHERE user_id = auth.uid()
  )
);
```

**Tradu√ß√£o:** "Retorne projetos de organiza√ß√µes onde usu√°rio √© membro"

---

**Teste:**

Dados:
```
Organizations
| id    | nome        |
|-------|-------------|
| org-1 | Empresa A   |
| org-2 | Empresa B   |

User_Organizations
| user_id  | organization_id |
|----------|-----------------|
| user-abc | org-1           |
| user-abc | org-2           | ‚Üê User pertence a 2 orgs
| user-def | org-2           |

Projetos
| id | organization_id | nome         |
|----|-----------------|--------------|
| 1  | org-1           | Projeto A1   |
| 2  | org-2           | Projeto B1   |
```

Jo√£o (user-abc) faz:
```sql
SELECT * FROM projetos;
```

**Retorna:**
```
| id | organization_id | nome         |
|----|-----------------|--------------|
| 1  | org-1           | Projeto A1   | ‚úÖ Membro de org-1
| 2  | org-2           | Projeto B1   | ‚úÖ Membro de org-2
```

---

Pedro (user-def) faz:
```sql
SELECT * FROM projetos;
```

**Retorna:**
```
| id | organization_id | nome         |
|----|-----------------|--------------|
| 2  | org-2           | Projeto B1   | ‚úÖ Membro de org-2
```

**N√ÉO retorna Projeto A1 (n√£o √© membro de org-1).**

---

### Exemplo 4: Com Indexes (Performance)

**Problema:** Queries com tenant_id podem ficar LENTAS se n√£o tiver index.

**Solu√ß√£o:** Criar index em tenant_id.

```sql
CREATE INDEX idx_clientes_tenant_id ON clientes(tenant_id);
```

**Por qu√™?**

Quando voc√™ faz:
```sql
SELECT * FROM clientes WHERE tenant_id = 'tenant-1';
```

Sem index: Banco varre TODAS as linhas (SLOW)
Com index: Banco pula direto pras linhas certas (FAST)

---

**Regra geral:**

Se voc√™ filtra por uma coluna COM FREQU√äNCIA:
‚Üí Crie um index nela

```sql
-- tenant_id (sempre filtra)
CREATE INDEX idx_clientes_tenant_id ON clientes(tenant_id);

-- user_id (sempre filtra)
CREATE INDEX idx_tarefas_user_id ON tarefas(user_id);

-- organization_id (sempre filtra)
CREATE INDEX idx_projetos_organization_id ON projetos(organization_id);
```

---

### Exemplo 5: Performance Tuning (tenant_id no √çndice)

**Cen√°rio:** Query lenta com m√∫ltiplos filtros.

**Query:**
```sql
SELECT * FROM clientes
WHERE tenant_id = 'tenant-1'
  AND status = 'active';
```

**Solu√ß√£o:** Index composto.

```sql
CREATE INDEX idx_clientes_tenant_status
ON clientes(tenant_id, status);
```

**Por qu√™?**

Banco usa √≠ndice composto pra filtrar AMBAS as condi√ß√µes ao mesmo tempo.

**Resultado:** Query 10x-100x mais r√°pida.

---

**Regra:**

Se voc√™ filtra por `tenant_id` + outra coluna com frequ√™ncia:
‚Üí Crie um index composto

```sql
CREATE INDEX idx_clientes_tenant_status ON clientes(tenant_id, status);
CREATE INDEX idx_tarefas_user_concluida ON tarefas(user_id, concluida);
```

---

## üåü EXPANS√ÉO FILOS√ìFICA (Camada 5)

Sabe por que te mostro isso?

Porque multi-tenant parece SUPER complicado.

Mas √© LITERALMENTE a mesma coisa que user_id.

---

Voc√™ J√Å faz isso:

**Filtrar por user_id:**
```sql
WHERE user_id = auth.uid()
```

**Filtrar por tenant_id:**
```sql
WHERE tenant_id = (SELECT tenant_id FROM auth.users WHERE id = auth.uid())
```

**√â A MESMA L√ìGICA.**

S√≥ que agora voc√™ isola por ORGANIZA√á√ÉO em vez de USU√ÅRIO.

---

**Multi-tenant = forma profissional de rodar SaaS.**

Porque:
1. 1 banco pra N clientes (custo baixo)
2. RLS isola dados automaticamente (seguran√ßa)
3. Performance OK com indexes (escalabilidade)

---

**Confessa que voc√™ tinha medo de multi-tenant?**

Pois √©.

Era s√≥ falta de informa√ß√£o.

Multi-tenant √© SUPER simples quando algu√©m explica certo.

---

## ‚úÖ RECAPITULA√á√ÉO (Valida√ß√£o do Aprendizado)

Antes de ir pra pr√≥xima aula, me responde mentalmente:

**1. Qual a diferen√ßa entre tenant e user?**
<details>
<summary>Resposta</summary>
Tenant = organiza√ß√£o/cliente. User = usu√°rio individual. 1 tenant pode ter N users.
</details>

**2. Como armazenar tenant_id no user?**
<details>
<summary>Resposta</summary>
Op√ß√£o 1: Coluna tenant_id na tabela auth.users. Op√ß√£o 2: app_metadata no JWT.
</details>

**3. Como criar policy que filtra por tenant_id?**
<details>
<summary>Resposta</summary>
USING (tenant_id = (SELECT tenant_id FROM auth.users WHERE id = auth.uid()))
</details>

**4. Por que criar index em tenant_id?**
<details>
<summary>Resposta</summary>
Porque queries filtram por tenant_id com frequ√™ncia. Index acelera busca.
</details>

**5. O que √© index composto?**
<details>
<summary>Resposta</summary>
Index em m√∫ltiplas colunas (ex: tenant_id + status). Acelera queries com m√∫ltiplos filtros.
</details>

---

Tudo claro?

Porque na pr√≥xima aula, vamos falar de DEBUGGING.

Como debugar quando RLS quebra (e vai quebrar).

---

## üéØ EXERC√çCIO PR√ÅTICO

**Seu desafio:**

Configure multi-tenant completo:

```sql
-- 1. Criar tenants
CREATE TABLE tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT
);

-- 2. Adicionar tenant_id em users
ALTER TABLE auth.users ADD COLUMN tenant_id UUID REFERENCES tenants(id);

-- 3. Criar tabela de produtos
CREATE TABLE produtos (
  id BIGSERIAL PRIMARY KEY,
  tenant_id UUID REFERENCES tenants(id),
  nome TEXT,
  preco DECIMAL
);

-- 4. Habilitar RLS
ALTER TABLE produtos ENABLE ROW LEVEL SECURITY;

-- 5. Criar policy SELECT
CREATE POLICY "Users see own tenant products"
ON produtos
FOR SELECT
USING (
  tenant_id = (
    SELECT tenant_id
    FROM auth.users
    WHERE id = auth.uid()
  )
);

-- 6. Criar policy INSERT
CREATE POLICY "Users insert own tenant products"
ON produtos
FOR INSERT
WITH CHECK (
  tenant_id = (
    SELECT tenant_id
    FROM auth.users
    WHERE id = auth.uid()
  )
);

-- 7. Criar index
CREATE INDEX idx_produtos_tenant_id ON produtos(tenant_id);
```

---

**Teste:**

Insira dados:
```sql
-- Tenants
INSERT INTO tenants (id, nome) VALUES
  ('tenant-1', 'Loja A'),
  ('tenant-2', 'Loja B');

-- Users (simulado)
INSERT INTO auth.users (id, tenant_id, email) VALUES
  ('user-abc', 'tenant-1', 'joao@loja-a.com'),
  ('user-def', 'tenant-2', 'pedro@loja-b.com');

-- Produtos
INSERT INTO produtos (tenant_id, nome, preco) VALUES
  ('tenant-1', 'Produto A1', 10.00),
  ('tenant-1', 'Produto A2', 20.00),
  ('tenant-2', 'Produto B1', 30.00);
```

Fa√ßa login como Jo√£o (tenant-1) e rode:
```sql
SELECT * FROM produtos;
```

**O que deve retornar?**

---

**Resposta esperada:**

```
| id | tenant_id | nome        | preco |
|----|-----------|-------------|-------|
| 1  | tenant-1  | Produto A1  | 10.00 |
| 2  | tenant-1  | Produto A2  | 20.00 |
```

**N√ÉO retorna Produto B1 (tenant-2).**

---

**Checklist Antes de Continuar:**
- [ ] Entendi diferen√ßa entre tenant e user
- [ ] Criei policy que filtra por tenant_id
- [ ] Criei index em tenant_id
- [ ] Testei isolamento entre tenants

Se marcou os 4, vamos pra pr√≥xima! üöÄ

---

## üöÄ PR√ìXIMO PASSO

Na pr√≥xima aula (07.5), vamos:
- ‚úÖ Debugar erros comuns de RLS
- ‚úÖ Entender "new row violates policy"
- ‚úÖ Usar EXPLAIN pra performance
- ‚úÖ Resolver auth.uid() = NULL

RLS quebra de forma silenciosa.

Voc√™ vai aprender a detectar e resolver.

Bora? üî•

---

**Metadados da Aula:**
- Criada por: Jos√© Amorim (Professor Socr√°tico)
- Framework: Espiral Expansiva + Anti-Impostor Design
- Dura√ß√£o estimada: 15 minutos
- Alignment Target: 95%+ (Objetivo ‚Üí Conte√∫do ‚Üí Exerc√≠cio)
- Fidelity Target: 93%+ (Voice Jos√© Amorim)
- Completeness: 100% (7 camadas + exerc√≠cio + checklist)
