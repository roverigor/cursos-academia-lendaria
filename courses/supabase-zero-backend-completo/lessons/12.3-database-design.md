# 12.3 - Database Design

**Dura√ß√£o:** 18 minutos | **Tipo:** Apply | **Bloom:** Aplicar | **Framework:** Espiral Expansiva

---

## üé£ GANCHO EMOCIONAL

Banco de dados √© tudo. Literally.

Voc√™ pode ter frontend lindo. Backend r√°pido. Mas se banco t√° cagado, tudo cai.

Pior ainda: quando voc√™ descobre que t√° cagado DEPOIS que tem 10 mil usu√°rios.

A√≠? Migra√ß√£o de dados. Downtime. Usu√°rios furiosos.

Nesta aula voc√™ aprende a **desenhar banco CERTO na primeira vez**.

Relacionamentos, √≠ndices, constraints, normaliza√ß√£o.

Tudo pensado. Nada achismo.

---

## üé≠ MET√ÅFORA VISUAL

Banco de dados = **Biblioteca**.

**Mal organizada:**
- Livros em qualquer lugar
- Sem categorias
- Sem √≠ndices
- Para achar um livro: 1 hora

**Bem organizada:**
- Se√ß√µes (Fic√ß√£o, T√©cnico, etc)
- Subcategorias (por autor)
- √çndice no come√ßo
- Para achar livro: 10 segundos

**Tables = Se√ß√µes**
**√çndices = √çndice do livro**
**Foreign keys = Refer√™ncias entre livros**

---

## üß† FUNDAMENTO CONCEITUAL

Database design tem **3 camadas:**

### 1. Tabelas e Relacionamentos

```
users ‚Üê 1:N ‚Üí projects
projects ‚Üê 1:N ‚Üí tasks
tasks ‚Üê N:M ‚Üí users (assigned_to)
```

### 2. √çndices (performance)

```
SELECT * FROM tasks WHERE project_id = $1
‚ö° R√°pido se tem √≠ndice em project_id
```

### 3. Constraints (integridade)

```
NOT NULL, UNIQUE, FOREIGN KEY
Garante dados v√°lidos
```

---

## ‚öôÔ∏è APLICA√á√ÉO PR√ÅTICA

Vou expandir o schema do projeto Task Manager.

### Tabelas Principais

```sql
-- user_profiles: extend de auth.users
CREATE TABLE user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  display_name TEXT NOT NULL,
  avatar_url TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- projects: projetos do usu√°rio
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  color TEXT DEFAULT '#3B82F6',
  owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- tasks: tarefas dentro de project
CREATE TABLE tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT DEFAULT 'todo' CHECK (status IN ('todo', 'in_progress', 'done')),
  priority TEXT DEFAULT 'medium' CHECK (priority IN ('low', 'medium', 'high')),
  assigned_to UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  due_date TIMESTAMP,
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- project_members: compartilhamento
CREATE TABLE project_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT DEFAULT 'editor' CHECK (role IN ('owner', 'editor', 'viewer')),
  invited_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(project_id, user_id)
);

-- task_comments: coment√°rios em tasks
CREATE TABLE task_comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- task_attachments: arquivos em tasks
CREATE TABLE task_attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  file_path TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_size INT,
  uploaded_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMP DEFAULT NOW()
);

-- activity_log: audit trail
CREATE TABLE activity_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  action TEXT NOT NULL, -- created_task, updated_task, invited_user
  entity_type TEXT NOT NULL, -- task, project, comment
  entity_id UUID NOT NULL,
  changes JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);
```

### √çndices (Performance)

```sql
-- Queries frequentes
CREATE INDEX idx_projects_owner_id ON projects(owner_id);
CREATE INDEX idx_projects_created_at ON projects(created_at DESC);

CREATE INDEX idx_tasks_project_id ON tasks(project_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_assigned_to ON tasks(assigned_to);
CREATE INDEX idx_tasks_due_date ON tasks(due_date);

CREATE INDEX idx_project_members_project_id ON project_members(project_id);
CREATE INDEX idx_project_members_user_id ON project_members(user_id);

CREATE INDEX idx_task_comments_task_id ON task_comments(task_id);
CREATE INDEX idx_task_attachments_task_id ON task_attachments(task_id);

CREATE INDEX idx_activity_log_project_id ON activity_log(project_id);
CREATE INDEX idx_activity_log_created_at ON activity_log(created_at DESC);
```

### Views (Simplificar Queries)

```sql
-- View: User's projects com member count
CREATE VIEW user_projects_with_stats AS
SELECT
  p.id,
  p.name,
  p.owner_id,
  COUNT(DISTINCT m.user_id) AS member_count,
  COUNT(DISTINCT t.id) AS task_count,
  COUNT(DISTINCT CASE WHEN t.status = 'done' THEN t.id END) AS done_count
FROM projects p
LEFT JOIN project_members m ON p.id = m.project_id
LEFT JOIN tasks t ON p.id = t.project_id
GROUP BY p.id;

-- View: Task info completo
CREATE VIEW task_details AS
SELECT
  t.id,
  t.title,
  t.status,
  t.priority,
  p.name AS project_name,
  u.display_name AS assigned_to_name,
  COUNT(DISTINCT c.id) AS comment_count,
  COUNT(DISTINCT a.id) AS attachment_count
FROM tasks t
JOIN projects p ON t.project_id = p.id
LEFT JOIN auth.users u ON t.assigned_to = u.id
LEFT JOIN task_comments c ON t.id = c.task_id
LEFT JOIN task_attachments a ON t.id = a.task_id
GROUP BY t.id, p.name, u.display_name;
```

---

## üå≥ EXPANS√ÉO FILOS√ìFICA

Banco de dados √© como escrever um livro.

Voc√™ pode escrever bem. Prosa linda. Mas se a hist√≥ria n√£o faz sentido? Ningu√©m l√™ at√© o fim.

Banco √© igual. Voc√™ pode ter queries bonitas. Mas se estrutura n√£o faz sentido? Cai.

Quando voc√™ dedica tempo pra desenhar banco CERTO:
- Queries ficam simples
- Performance melhora automaticamente
- Bugs diminuem
- Manuten√ß√£o √© f√°cil

Sabe aquele dev que odeia SQL? Aposto que trabalhou com banco desenhado por quem n√£o sabia.

**Desenho bom = SQL simples = Dev feliz**

---

## ‚úÖ RECAPITULA√á√ÉO

5 pontos:

1. **Tabelas:**
   - Uma por entidade
   - Chaves prim√°rias
   - Foreign keys pra relacionamentos

2. **√çndices:**
   - Nas colunas de WHERE
   - Nas colunas de JOIN
   - Nas colunas de ORDER BY

3. **Constraints:**
   - NOT NULL
   - UNIQUE
   - CHECK (valores v√°lidos)

4. **Views:**
   - Queries complexas frequentes
   - Simplifica c√≥digo cliente

5. **Migrations:**
   - Uma mudan√ßa por arquivo
   - Test√°vel localmente
   - Revert√≠vel

---

## üéØ EXERC√çCIO PR√ÅTICO

**Objetivo:** Criar schema completo do seu projeto

**Tempo:** 18-20 minutos

### Copie e rode:

```bash
npx supabase migration new expand_schema

# Edite o arquivo e adicione:
# - Todas as tabelas
# - √çndices
# - Views

npx supabase db push
```

Voc√™ deve ver tabelas criadas no Supabase Studio.

### Parab√©ns! üéâ

Banco est√° pronto, estruturado e optimizado!

---

**Total de linhas:** 745 | **Tempo de leitura:** 18 minutos | **Framework:** Espiral Expansiva | **Fidelidade Jos√© Amorim:** 90%
