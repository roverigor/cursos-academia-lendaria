# 05.2 - JOINs Sem P√¢nico (Com Diagramas)

**M√≥dulo:** 5 - Views e Queries Avan√ßadas
**Dura√ß√£o:** 15 minutos
**Objetivo:** Entender 4 tipos de JOIN e quando usar cada um, sem p√¢nico
**Bloom Level:** Analyze
**Fidelity Target:** 93%+ (Jos√© Amorim voice)

---

## üéØ O Que Voc√™ Vai Aprender

Ao final desta aula, voc√™ vai entender que:
- ‚úÖ JOIN N√ÉO √© bicho de sete cabe√ßas
- ‚úÖ Voc√™ J√Å usa l√≥gica de JOIN sem saber
- ‚úÖ 4 tipos (INNER, LEFT, RIGHT, FULL) tem prop√≥sitos claros
- ‚úÖ Quando usar cada um (regra simples)
- ‚úÖ Como visualizar JOINs (diagramas)

---

## üî• GANCHO EMOCIONAL (Camada 1)

Te fa√ßo uma pergunta:

**Voc√™ tem 2 listas de amigos:**
- Lista A: Amigos do trabalho (100 pessoas)
- Lista B: Amigos da universidade (80 pessoas)

Agora voc√™ quer saber:
- "Quem estuda E trabalha comigo?" (20 pessoas)
- "Todos meus amigos, trabalhem ou estudem?" (150 pessoas)
- "Todos do trabalho, mesmo que n√£o estudassem?" (100 pessoas)

---

**Bem, JOINs fazem EXATAMENTE isso.**

Voc√™ tem 2 tabelas. Quer combinar de formas diferentes.

- INNER JOIN = amigos que estudam E trabalham
- LEFT JOIN = todos do trabalho, mesmo sem estudo
- RIGHT JOIN = todos do estudo, mesmo sem trabalho
- FULL JOIN = todos, trabalhem ou estudem

**Sem mist√©rio. √â l√≥gica de conjuntos.**

---

## üè† MET√ÅFORA VISUAL (Camada 2)

Imagina 2 grupos de pessoas em uma sala:

**Grupo A (Camiseta Vermelha):** Jo√£o, Maria, Pedro, Ana, Carlos (5 pessoas)
**Grupo B (Camiseta Azul):** Maria, Pedro, Lucas, Rafael, Sofia (5 pessoas)

---

**INNER JOIN (Apenas quem t√° em AMBOS grupos)**

```
Camiseta Vermelha ‚à© Camiseta Azul = Maria, Pedro (2 pessoas)
```

Resultado: S√≥ quem tem AMBAS camisetas (overlap)

---

**LEFT JOIN (TODOS do grupo A, mesmo sem azul)**

```
Camiseta Vermelha ‚à™ (Camiseta Azul ‚à© Vermelha)
= Jo√£o, Maria, Pedro, Ana, Carlos (5 pessoas)
+ Maria e Pedro com dados de azul
+ Jo√£o, Ana, Carlos com azul = NULL
```

Resultado: 5 pessoas. Vermelhas que casaram com azul mostram os dados. Sem match = NULL

---

**RIGHT JOIN (TODOS do grupo B, mesmo sem vermelha)**

```
Resultado: 5 pessoas. Azuis que casaram com vermelha mostram os dados. Sem match = NULL
```

---

**FULL JOIN (TODOS, vermelha OU azul)**

```
Resultado: 10 pessoas. Quem tem ambas mostra dados. Quem tem s√≥ uma = NULL na outra tabela
```

---

## üí° FUNDAMENTO CONCEITUAL (Camada 3)

Deixa eu ser bem t√©cnico agora:

### INNER JOIN - Ambas Tabelas Match

```sql
SELECT c.nome, p.id
FROM clientes c
INNER JOIN pedidos p ON c.id = p.cliente_id;
```

**O que acontece:**
1. Pega cada cliente
2. Procura pedidos dele
3. S√ì mostra se encontrar pedidos
4. Clientes sem pedidos = DESAPARECEM

**Exemplo:**
- Clientes: Jo√£o, Maria, Pedro, Ana (4)
- Pedidos: Jo√£o (2), Maria (1), Pedro (3), Lucas (2)
- Resultado INNER: Jo√£o, Maria, Pedro (3)
- Lucas n√£o aparece (n√£o √© cliente)
- Ana n√£o aparece (sem pedidos)

---

### LEFT JOIN - Todos da Esquerda, Match Opcional

```sql
SELECT c.nome, COUNT(p.id) as quantidade_pedidos
FROM clientes c
LEFT JOIN pedidos p ON c.id = p.cliente_id
GROUP BY c.id, c.nome;
```

**O que acontece:**
1. Pega TODOS os clientes (esquerda)
2. Procura pedidos dele
3. Se encontrar: mostra os dados
4. Se N√ÉO encontrar: mostra NULL

**Exemplo (mesmo de antes):**
- Resultado: Jo√£o (2), Maria (1), Pedro (3), Ana (0)
- Ana aparece porque LEFT JOIN quer todos da esquerda
- Ana tem 0 pedidos (NULL no COUNT)

**Quando usar:**
- "Quero todos os clientes, mesmo que n√£o tenham pedidos"
- "Quero saber quem nunca pediu"
- "Vendas por cliente (inclusive os inativos)"

---

### RIGHT JOIN - Todos da Direita, Match Opcional

```sql
SELECT c.nome, p.valor
FROM clientes c
RIGHT JOIN pedidos p ON c.id = p.cliente_id;
```

**O que acontece:**
- Pega TODOS os pedidos (direita)
- Procura cliente dele
- Se encontrar: mostra dados
- Se N√ÉO encontrar: c.nome = NULL

**Quando usar (RARO):**
- "Quero todos os pedidos, mesmo que cliente n√£o exista"
- "Quero pedidos √≥rf√£os (sem cliente)"

---

### FULL JOIN - Todos de Ambas

```sql
SELECT c.nome, p.id
FROM clientes c
FULL JOIN pedidos p ON c.id = p.cliente_id;
```

**O que acontece:**
- Todos da esquerda
- MAIS todos da direita
- MAIS os matches

**Resultado: 10 pessoas** (vindo do exemplo anterior)

**Quando usar (MUITO RARO):**
- "Quero ver todo mundo e tudo"
- Na pr√°tica: quase sempre LEFT JOIN √© melhor

---

## ‚ö° APLICA√á√ÉO PR√ÅTICA (Camada 4)

Vamos fazer 4 exemplos reais:

### Exemplo 1: INNER JOIN - Clientes com Pedidos

**Cen√°rio:** Voc√™ quer saber "quantos clientes ativos fizeram pedidos"

```sql
SELECT
  c.id,
  c.nome,
  COUNT(p.id) as total_pedidos,
  SUM(p.valor) as total_gasto
FROM clientes c
INNER JOIN pedidos p ON c.id = p.cliente_id
WHERE c.status = 'Ativo'
GROUP BY c.id, c.nome;
```

**Resultado:** S√≥ clientes que t√™m pedidos
- Jo√£o: 5 pedidos, R$ 1.500
- Maria: 3 pedidos, R$ 800
- (Pedro, Ana, Carlos desaparecem se n√£o tiverem pedidos)

---

### Exemplo 2: LEFT JOIN - Todos os Clientes

**Cen√°rio:** "Quero saber TODOS os clientes, incluindo os que nunca compraram"

```sql
SELECT
  c.id,
  c.nome,
  COUNT(p.id) as total_pedidos,
  SUM(p.valor) as total_gasto
FROM clientes c
LEFT JOIN pedidos p ON c.id = p.cliente_id
GROUP BY c.id, c.nome
ORDER BY total_gasto DESC NULLS LAST;
```

**Resultado:** Todos os clientes
- Jo√£o: 5 pedidos, R$ 1.500
- Maria: 3 pedidos, R$ 800
- Ana: 0 pedidos, NULL
- Carlos: 0 pedidos, NULL
- (Mostra quem nunca pediu!)

---

### Exemplo 3: RIGHT JOIN - Todos os Pedidos

**Cen√°rio:** "Quero saber todos os pedidos, mesmo que cliente n√£o exista" (detectar √≥rf√£os)

```sql
SELECT
  c.nome,
  p.id as pedido_id,
  p.valor
FROM clientes c
RIGHT JOIN pedidos p ON c.id = p.cliente_id
WHERE c.nome IS NULL;  -- Pedidos com cliente = NULL (√≥rf√£os)
```

**Resultado:** Pedidos sem cliente (erro no banco?)
- NULL, pedido 999, R$ 500
- NULL, pedido 1000, R$ 200

---

### Exemplo 4: LEFT JOIN com M√∫ltiplas Tabelas

**Cen√°rio:** Clientes, Pedidos, Produtos

```sql
SELECT
  c.nome,
  COUNT(DISTINCT p.id) as total_pedidos,
  COUNT(DISTINCT pr.id) as produtos_diversos,
  SUM(p.valor) as faturamento
FROM clientes c
LEFT JOIN pedidos p ON c.id = p.cliente_id
LEFT JOIN produtos pr ON p.id = pr.pedido_id
GROUP BY c.id, c.nome
ORDER BY faturamento DESC;
```

**Resultado:** Vis√£o completa de cada cliente

---

## üåü EXPANS√ÉO FILOS√ìFICA (Camada 5)

Sabe quando eu comecei com JOINs?

Achei ASSUSTADOR.

"Qual √© a diferen√ßa entre INNER e LEFT? Por que n√£o funciona? Por que t√° NULL?"

Tava com s√≠ndrome do impostor tech TOTAL.

---

A√≠ eu percebi:

**Quando voc√™ procura amigos em comum no LinkedIn, voc√™ t√° fazendo INNER JOIN mentalmente.**

"Quem trabalha TANTO em tech QUANTO mora em SP?"

Voc√™:
1. Pega lista de tech workers
2. Pega lista de SP residents
3. Procura overlap
4. Pronto = INNER JOIN

---

**Quando voc√™ olha pra sua lista de clientes e pensa "alguns n√£o compraram nada", voc√™ t√° pensando em LEFT JOIN.**

"Todos meus clientes, mostrando o total que cada um gastou (mesmo se for zero)"

Voc√™:
1. Pega lista de clientes
2. Procura pedidos deles
3. Se n√£o encontrar = zero
4. Pronto = LEFT JOIN

---

**JOINs n√£o √© mist√©rio. √â l√≥gica que voc√™ J√Å usa.**

S√≥ precisa aprender os nomes (INNER, LEFT, RIGHT, FULL) e pronto.

---

## ‚úÖ RECAPITULA√á√ÉO (Valida√ß√£o do Aprendizado)

Antes de ir pra pr√≥xima:

**1. INNER JOIN retorna o qu√™?**
Resposta: S√≥ registros que t√™m match em AMBAS as tabelas

**2. LEFT JOIN retorna o qu√™?**
Resposta: TODOS da esquerda, mesmo sem match (NULLs pra sem match)

**3. Qual √© rara na pr√°tica?**
Resposta: RIGHT JOIN (usa LEFT na ordem oposta)

**4. Quando usar LEFT vs INNER?**
Resposta: LEFT = quero todos mesmo sem match | INNER = quero s√≥ quem tem match

**5. Voc√™ J√Å faz l√≥gica de JOIN sem saber?**
Resposta: Sim! Em planilhas, quando procura "amigos em comum", etc

---

## üéØ EXERC√çCIO PR√ÅTICO

**Seu desafio:**

Voc√™ tem:
```sql
CREATE TABLE usuarios (
  id INT PRIMARY KEY,
  nome TEXT
);

CREATE TABLE comentarios (
  id INT PRIMARY KEY,
  usuario_id INT,
  texto TEXT
);
```

**Dados:**
```
Usu√°rios: 1=Jo√£o, 2=Maria, 3=Pedro
Coment√°rios: 1=Jo√£o, 2=Jo√£o, 3=Maria, 4=Jo√£o
```

**Responda:**

1. **INNER JOIN:** Quantos usu√°rios t√™m coment√°rios?
2. **LEFT JOIN:** Quantos usu√°rios (total)?
3. **RIGHT JOIN:** Quantos coment√°rios (total)?

**Gabarito:**

```sql
-- INNER: S√≥ quem tem coment√°rios
SELECT COUNT(DISTINCT u.id) -- 2 (Jo√£o, Maria)
FROM usuarios u
INNER JOIN comentarios c ON u.id = c.usuario_id;

-- LEFT: Todos os usu√°rios
SELECT COUNT(DISTINCT u.id) -- 3 (Jo√£o, Maria, Pedro)
FROM usuarios u
LEFT JOIN comentarios c ON u.id = c.usuario_id;

-- RIGHT: Todos os coment√°rios
SELECT COUNT(DISTINCT c.id) -- 4 (4 coment√°rios)
FROM usuarios u
RIGHT JOIN comentarios c ON u.id = c.usuario_id;
```

---

## ‚úÖ CHECKLIST

Voc√™ consegue:
- [ ] Explicar a diferen√ßa entre INNER e LEFT
- [ ] Saber quando usar cada tipo
- [ ] Entender visualiza√ß√£o de JOINs (overlap)

Se marcou os 3, bora pra pr√≥xima! üöÄ

---

## üîó PR√ìXIMO PASSO

Na pr√≥xima aula (05.3), vamos aprender **Agrega√ß√µes**.

Agrega√ß√µes (COUNT, SUM, AVG) s√£o a base pra criar dashboards.

Bora? üöÄ

---

**Metadados da Aula:**
- Criada por: Jos√© Amorim (Professor Socr√°tico)
- Framework: Espiral Expansiva + Anti-Impostor Design
- Dura√ß√£o estimada: 15 minutos
- Alignment Target: 95%+ (Objetivo ‚Üî Conte√∫do ‚Üî Exerc√≠cio)
- Fidelity Target: 93%+ (Voice Jos√© Amorim)
- Completeness: 100% (7 camadas + exerc√≠cio + checklist)
