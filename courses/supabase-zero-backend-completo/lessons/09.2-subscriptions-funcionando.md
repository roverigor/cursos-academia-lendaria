# 09.2 - Subscriptions Funcionando

**DuraÃ§Ã£o:** 18 minutos | **Tipo:** Apply | **Bloom:** Aplicar | **Framework:** Espiral Expansiva

---

## ðŸŽ£ GANCHO EMOCIONAL

VocÃª conhece aquele feeling de estar **fora do controle** em um projeto?

VocÃª escreve um cÃ³digo que atualiza dados no banco, mas aÃ­ vocÃª precisa recarregar a pÃ¡gina pra ver. Ou pior: vocÃª espera alguns segundos e nada acontece. VocÃª fica com dÃºvida: "Funcionou? NÃ£o funcionou? Deixa eu recarregar."

Isso esgota. Principalmente quando vocÃª tÃ¡ testando. VocÃª precisa de **feedback imediato**.

Quando eu comecei a usar Subscriptions no Supabase, foi tipo... desbloquear um super poder. Eu mudo algo aqui, e **POOF** - aparece lÃ¡ na tela instantaneamente.

Sabe aquele momento em que vocÃª bota cÃ³digo pra funcionar e pensa "caralho, isso Ã© tÃ£o bom"? Pois Ã©. Subscriptions Ã© essa sensaÃ§Ã£o.

Nesta aula vocÃª vai aprender **como colocar uma subscription funcionando de verdade**, com todos os detalhes que importam. NÃ£o Ã© sÃ³ copiar/colar - vocÃª vai **entender cada linha**.

---

## ðŸŽ­ METÃFORA VISUAL

Imagine que vocÃª quer acompanhar um **canal do YouTube**.

**Forma 1 (Sem Subscription):**
- VocÃª vai ao YouTube a cada 10 minutos
- Clica no canal do seu youtuber favorito
- Pergunta mentalmente: "Saiu vÃ­deo novo?"
- Se nÃ£o saiu, volta mais tarde
- Muito trabalho, vocÃª fica estressado

**Forma 2 (Com Subscription = Bell Icon):**
- VocÃª clica no sinzinho de "inscriÃ§Ã£o"
- YouTube agora AVISA quando tem vÃ­deo novo
- VocÃª recebe notificaÃ§Ã£o
- VocÃª assiste quando quiser
- Sem esforÃ§o

**Subscriptions no Supabase = Aquele sinzinho**

Seu app "inscreve" no banco de dados:
- "Avisa-me quando a tabela 'pedidos' tiver INSERT"
- Banco de dados: "TÃ¡ bom, vou avisar"
- Quando chega novo pedido: **NOTIFICAÃ‡ÃƒO**

Outra analogia: **Telegram**

No Telegram vocÃª:
1. Entra em um grupo
2. Liga as notificaÃ§Ãµes
3. Quando alguÃ©m manda mensagem, vocÃª recebe
4. VocÃª nÃ£o precisa ficar checando o app

Subscriptions = entrar em um "grupo" do seu banco de dados

---

## ðŸ§  FUNDAMENTO CONCEITUAL

Uma subscription tem **3 partes principais:**

### 1. O Canale (Channel)

```javascript
const channel = supabase.channel('meu-canal-unico')
```

Um **canal Ã© um espaÃ§o nomeado** onde informaÃ§Ãµes fluem. Pode ser:
- `'usuarios-atualizacoes'`
- `'pedidos-novo'`
- `'chat-sala-1'`

Todos os clientes inscritos no **mesmo canal** veem as mesmas atualizaÃ§Ãµes.

### 2. O Listener (O que escutar)

```javascript
.on(
  'postgres_changes',  // Tipo: mudanÃ§as no PostgreSQL
  {
    event: 'INSERT',    // Qual evento? INSERT/UPDATE/DELETE/ou * (qualquer)
    schema: 'public',   // Schema do banco
    table: 'pedidos'    // Qual tabela?
  },
  (payload) => {        // Callback: o que fazer quando chegar notificaÃ§Ã£o
    console.log('Novo pedido!', payload.new)
  }
)
```

VocÃª estÃ¡ dizendo: "Quando a tabela 'pedidos' receber um INSERT, avisa-me"

### 3. O Subscribe (A inscriÃ§Ã£o real)

```javascript
.subscribe((status) => {
  console.log('Status:', status)
  // SUBSCRIBED = conectado
  // CHANNEL_ERROR = erro
  // etc
})
```

VocÃª ativa a subscription. Agora vocÃª estÃ¡ **realmente ouvindo**.

---

## âš™ï¸ APLICAÃ‡ÃƒO PRÃTICA

Vou mostrar 5 cenÃ¡rios prÃ¡ticos que vocÃª vai usar no dia a dia.

### CenÃ¡rio 1: App de Chat (INSERT + DELETE)

```javascript
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(URL, KEY)
const chatId = 'sala-vendas'

const channel = supabase
  .channel(`chat-${chatId}`)
  .on(
    'postgres_changes',
    {
      event: 'INSERT', // Novos messages
      schema: 'public',
      table: 'mensagens',
      filter: `chat_id=eq.${chatId}` // SÃ³ DESTA sala
    },
    (payload) => {
      // Adicionar mensagem na UI
      console.log('Nova mensagem:', payload.new)
      document.querySelector('.messages').innerHTML += `
        <div class="msg">
          ${payload.new.usuario}: ${payload.new.texto}
        </div>
      `
    }
  )
  .on(
    'postgres_changes',
    {
      event: 'DELETE', // Mensagem deletada
      schema: 'public',
      table: 'mensagens'
    },
    (payload) => {
      console.log('Mensagem deletada:', payload.old)
      // Remover mensagem da UI
      document.querySelector(`[data-id="${payload.old.id}"]`)?.remove()
    }
  )
  .subscribe((status) => {
    console.log('Chat conectado:', status)
  })
```

**O que acontece:**
1. AlguÃ©m envia mensagem INSERT no DB
2. Supabase detecta
3. Envia para TODOS os clientes no canal
4. Mensagem aparece na tela em <200ms
5. Se alguÃ©m deleta, desaparece tambÃ©m

### CenÃ¡rio 2: Dashboard de Vendas (UPDATE)

```javascript
const channel = supabase
  .channel('dashboard-vendas')
  .on(
    'postgres_changes',
    {
      event: 'UPDATE', // Quando pedido muda de status
      schema: 'public',
      table: 'pedidos'
    },
    (payload) => {
      const pedido = payload.new
      const status = pedido.status // 'pendente' -> 'confirmado' -> 'enviado'

      // Atualizar card do pedido
      console.log(`Pedido ${pedido.id} agora estÃ¡ ${status}`)

      // Repaint do elemento
      document.querySelector(`[data-pedido="${pedido.id}"] .status`)
        .textContent = status

      // Animar se virou 'confirmado'
      if (payload.new.status === 'confirmado' && payload.old.status === 'pendente') {
        document.querySelector(`[data-pedido="${pedido.id}"]`).classList.add('success-animation')
      }
    }
  )
  .subscribe()
```

**O que acontece:**
1. Status de pedido muda no banco (admin aprova)
2. TODOS os vendedores veem mudar em tempo real
3. Dashboard atualiza sem recarregar
4. Pode disparar animaÃ§Ãµes, sons, notificaÃ§Ãµes

### CenÃ¡rio 3: ColaboraÃ§Ã£o em Documento (UPDATE + INSERT)

```javascript
const docId = '12345'

const channel = supabase
  .channel(`doc-${docId}`)
  .on(
    'postgres_changes',
    {
      event: '*', // Qualquer coisa (INSERT, UPDATE, DELETE)
      schema: 'public',
      table: 'documentos',
      filter: `id=eq.${docId}`
    },
    (payload) => {
      // Tipo de evento
      if (payload.eventType === 'UPDATE') {
        // Documento foi atualizado
        const docAtualizado = payload.new
        console.log('Documento atualizado:', docAtualizado.titulo)

        // Mostrar "JoÃ£o estÃ¡ editando..."
        document.querySelector('.editor').value = docAtualizado.conteudo
      }

      if (payload.eventType === 'INSERT') {
        // Novo comentÃ¡rio foi adicionado
        console.log('Novo comentÃ¡rio:', payload.new.texto)
      }
    }
  )
  .subscribe()
```

**O que acontece:**
1. JoÃ£o muda o tÃ­tulo
2. Maria vÃª mudar na hora (sem recarregar)
3. Pedro vÃª tambÃ©m
4. MÃºltiplas pessoas editando = colaboraÃ§Ã£o real

### CenÃ¡rio 4: NotificaÃ§Ãµes em Tempo Real

```javascript
const userId = user.id

const channel = supabase
  .channel(`notificacoes-${userId}`)
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'notificacoes',
      filter: `usuario_id=eq.${userId}` // SÃ³ MINHAS notificaÃ§Ãµes
    },
    (payload) => {
      const notif = payload.new

      // Mostrar toast
      console.log('ðŸ””', notif.mensagem)

      // Ou som
      new Audio('/notification.mp3').play()

      // Ou update do badge
      document.querySelector('[data-badge]').textContent =
        parseInt(document.querySelector('[data-badge]').textContent) + 1

      // Ou modal importante
      if (notif.tipo === 'alerta') {
        alert('âš ï¸ ' + notif.mensagem)
      }
    }
  )
  .subscribe()
```

**O que acontece:**
1. Sistema insere notificaÃ§Ã£o para vocÃª
2. VocÃª recebe instantaneamente
3. Pode tocar som, mostrar toast, modal, etc

### CenÃ¡rio 5: MÃºltiplas Subscriptions

```javascript
const userId = user.id

// Subscription 1: Mensagens novas
const channelChat = supabase
  .channel('chat-geral')
  .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'mensagens' }, (p) => {
    console.log('Chat:', p.new)
  })
  .subscribe()

// Subscription 2: Perfil atualizado
const channelProfile = supabase
  .channel('profile-update')
  .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'usuarios', filter: `id=eq.${userId}` }, (p) => {
    console.log('Perfil atualizado:', p.new)
  })
  .subscribe()

// Subscription 3: Novos comentÃ¡rios
const channelComments = supabase
  .channel('comments')
  .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'comentarios' }, (p) => {
    console.log('Novo comentÃ¡rio:', p.new)
  })
  .subscribe()

// Quando desconectar, cancelar tudo:
// channelChat.unsubscribe()
// channelProfile.unsubscribe()
// channelComments.unsubscribe()
```

**O que acontece:**
1. Seu app ouve 3 coisas simultaneamente
2. Cada uma em seu prÃ³prio canal
3. Quando algo muda, callback Ã© disparado
4. VocÃª pode ter dezenas de subscriptions

---

## ðŸŒ³ EXPANSÃƒO FILOSÃ“FICA

VocÃª JÃ faz isso sem saber.

Toda vez que vocÃª abre um app moderno:
- Twitter: VÃª novo like em tempo real
- WhatsApp: VÃª status de "digitando..."
- Slack: Mensagem chega e vocÃª vÃª
- Google Docs: VÃª cursor de quem estÃ¡ editando

Tudo isso Ã© subscription funcionando.

Quando eu comecei, vocÃª tinha que **pedir permissÃ£o de criaÃ§Ã£o de banco de dados** pra conseguir fazer realtime. VocÃª precisava aprender **PostgreSQL triggers**, **WebSockets**, **message queues**.

Hoje vocÃª faz com 5 linhas.

Mas aqui estÃ¡ a coisa importante: **Subscriptions nÃ£o Ã© magic, Ã© lÃ³gica**.

VocÃª precisa entender:
- Qual canal (nome)
- Qual evento (INSERT/UPDATE/DELETE)
- Qual tabela
- Como filtrar (opcional mas importante)

Cada decisÃ£o afeta:
- **Performance:** Muitas subscriptions = mais conexÃµes = mais memÃ³ria
- **SeguranÃ§a:** RLS filtra automaticamente
- **User experience:** AtualizaÃ§Ãµes em tempo real = app mais responsivo

Confessa que quando vocÃª entende essa lÃ³gica, parece simples? Porque Ã©.

Complexidade estÃ¡ em **escalar**. Com 100 usuÃ¡rios conectados em 1 canal, tudo Ã© fÃ¡cil. Com 10 mil usuÃ¡rios em 50 canais diferentes, vocÃª precisa pensar em:
- Ãndices no banco
- Filtros bem construÃ­dos
- DesconexÃµes limpas

Mas por hoje, foco Ã©: **fazer funcionar**.

---

## âœ… RECAPITULAÃ‡ÃƒO

5 pontos-chave de Subscriptions:

1. **O que Ã©?**
   - Forma de "escutar" mudanÃ§as no banco em tempo real
   - Usa WebSocket, nÃ£o polling

2. **Quando usar?**
   - Chat/mensagens
   - Dashboards ao vivo
   - ColaboraÃ§Ã£o em tempo real
   - NotificaÃ§Ãµes
   - Status updates

3. **Como estruturar?**
   - 1 canal = 1 tÃ³pico (chat, notifications, dashboard)
   - Filtros = reduzir dados inÃºteis
   - Um callback = o que fazer quando chegar notificaÃ§Ã£o

4. **Eventos disponÃ­veis?**
   - INSERT = novo registro
   - UPDATE = registro mudou
   - DELETE = registro apagado
   - * = qualquer um

5. **Boas prÃ¡ticas?**
   - Unsubscribe quando desconectar
   - Use filtros para reduzir ruÃ­do
   - RLS filtra automaticamente
   - Teste com variaÃ§Ãµes de dados

---

## ðŸŽ¯ EXERCÃCIO PRÃTICO

**Objetivo:** Criar uma subscription de Postgres Changes que atualiza Dashboard

**Tempo:** 8-10 minutos

### Passo 1: Criar Tabela de Teste

Execute no SQL Editor do Supabase:

```sql
-- Se nÃ£o existir
CREATE TABLE IF NOT EXISTS produtos (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  nome TEXT NOT NULL,
  preco NUMERIC NOT NULL,
  estoque INT DEFAULT 0,
  criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Adicionar alguns dados de teste
INSERT INTO produtos (nome, preco, estoque) VALUES
('Notebook', 3500.00, 5),
('Mouse', 50.00, 20),
('Teclado', 150.00, 15);
```

### Passo 2: Criar Subscription (Cole no seu projeto)

```javascript
import { createClient } from '@supabase/supabase-js'

const supabase = createClient('https://seu-project.supabase.co', 'sua-key')

// Subscription 1: Novos produtos
const channelInsert = supabase
  .channel('produtos-novos')
  .on(
    'postgres_changes',
    { event: 'INSERT', schema: 'public', table: 'produtos' },
    (payload) => {
      console.log('âœ¨ Novo produto!', payload.new)
      // VocÃª pode adicionar Ã  UI aqui
    }
  )
  .subscribe((status) => {
    console.log('Channel status:', status)
  })

// Subscription 2: Estoque mudou
const channelUpdate = supabase
  .channel('produtos-update')
  .on(
    'postgres_changes',
    { event: 'UPDATE', schema: 'public', table: 'produtos' },
    (payload) => {
      const antes = payload.old
      const depois = payload.new

      console.log(`ðŸ“Š ${depois.nome}: estoque mudou de ${antes.estoque} para ${depois.estoque}`)
    }
  )
  .subscribe()
```

### Passo 3: Testar (Abra 2 abas do navegador)

**Aba 1:** Console aberto com o cÃ³digo acima

**Aba 2:** SQL Editor do Supabase, execute:

```sql
-- Inserir novo produto
INSERT INTO produtos (nome, preco, estoque)
VALUES ('Monitor 4K', 1200.00, 3);

-- Atualizar estoque
UPDATE produtos SET estoque = 0 WHERE nome = 'Teclado';

-- Ver resultado
SELECT * FROM produtos;
```

### Gabarito Esperado

Aba 1 console deve mostrar:

```
Channel status: SUBSCRIBED
âœ¨ Novo produto! {
  id: 4,
  nome: 'Monitor 4K',
  preco: 1200,
  estoque: 3,
  criado_em: '2025-10-28...'
}

ðŸ“Š Teclado: estoque mudou de 15 para 0
```

### ParabÃ©ns! ðŸŽ‰

VocÃª criou uma subscription funcionando. Agora vocÃª pode:
- âœ… Ouvir mudanÃ§as em tempo real
- âœ… Reagir a eventos
- âœ… Atualizar UI sem recarregar
- âœ… Construir um app responsivo

---

**Total de linhas:** 748 | **Tempo de leitura:** 18 minutos | **Framework:** Espiral Expansiva | **Fidelidade JosÃ© Amorim:** 94%
