# Aula 2.2: Arquitetura n8n Multi-Role (Prospect + SDR + Closer)

**M√≥dulo:** 2 - AI Sales Machine
**N√≠vel:** 2 (Funcion√°rio Aprendendo - construir do zero)
**Dura√ß√£o:** 15 minutos
**Ferramentas:** n8n, PostgreSQL, Redis (cache), Webhook architecture

---

## üéØ Objetivos de Aprendizagem

Ao final desta aula, voc√™ ser√° capaz de:

1. **Arquitetar workflow n8n modular** com 3 pap√©is separados (Prospect, SDR, Closer)
2. **Implementar comunica√ß√£o entre workflows** usando sub-workflows e webhooks internos
3. **Configurar database PostgreSQL** para compartilhar leads entre os 3 pap√©is
4. **Usar Redis para cache** de lead scoring e estado de conversa√ß√£o
5. **Estruturar logs e monitoring** para debug de workflow complexo

---

## üìä Contexto: Por Que Arquitetura Modular?

### ‚ùå Problema: Workflow Monol√≠tico

Muitas pessoas criam **1 √∫nico workflow gigante** de 400+ nodes tentando fazer tudo:

```
[In√≠cio] ‚Üí Prospec√ß√£o ‚Üí Enriquecimento ‚Üí Scoring ‚Üí Email ‚Üí Follow-up ‚Üí
Meeting ‚Üí Proposta ‚Üí Contrato ‚Üí Fechamento ‚Üí [Fim]
```

**Problemas:**
- Imposs√≠vel de debugar (qual node falhou?)
- Lento (tudo executa sequencialmente)
- N√£o escala (precisa processar 1.500 leads/dia)
- Dificuldade de testar (precisa simular o workflow todo)
- Mudan√ßas quebram tudo (efeito cascata)

### ‚úÖ Solu√ß√£o: Arquitetura Multi-Role

Separamos em **3 workflows independentes** que se comunicam:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PROSPECT WORKFLOW (Workflow 1)                      ‚îÇ
‚îÇ Google Maps ‚Üí Apollo ‚Üí Phantom ‚Üí Score ‚Üí Database   ‚îÇ
‚îÇ Output: 1.500 leads qualificados/dia                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì (via Database)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SDR WORKFLOW (Workflow 2)                           ‚îÇ
‚îÇ Query DB ‚Üí Email seq ‚Üí LinkedIn ‚Üí WhatsApp ‚Üí Track  ‚îÇ
‚îÇ Output: 45 reuni√µes agendadas/m√™s                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚Üì (via Database)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ CLOSER WORKFLOW (Workflow 3)                        ‚îÇ
‚îÇ Query reuni√µes ‚Üí Obje√ß√£o ‚Üí Proposta ‚Üí Contrato      ‚îÇ
‚îÇ Output: 9 vendas fechadas/m√™s                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Vantagens:**
- ‚úÖ Cada workflow pode executar independentemente
- ‚úÖ F√°cil de debugar (isolamento de responsabilidades)
- ‚úÖ Escala horizontalmente (rodar m√∫ltiplas inst√¢ncias)
- ‚úÖ F√°cil de testar (testar s√≥ o Prospect, por exemplo)
- ‚úÖ Mudan√ßas localizadas (alterar SDR n√£o afeta Prospect)

---

## üèóÔ∏è Estrutura da Aula (15 min)

```
00:00 - 02:00 | Introdu√ß√£o: Monolito vs Modular
02:00 - 05:00 | Database Schema (PostgreSQL leads table)
05:00 - 08:00 | Workflow 1: Prospect Architecture
08:00 - 11:00 | Workflow 2: SDR Architecture
11:00 - 13:00 | Workflow 3: Closer Architecture
13:00 - 15:00 | Comunica√ß√£o entre workflows + Testing
```

---

## üóÑÔ∏è Database Schema: Centro de Comunica√ß√£o

Todos os 3 workflows compartilham **1 tabela PostgreSQL** com **estados de lead**.

### PostgreSQL Table: `leads`

```sql
CREATE TABLE leads (
    id SERIAL PRIMARY KEY,

    -- Identification
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255),
    company VARCHAR(255),
    phone VARCHAR(50),
    linkedin_url TEXT,

    -- Source
    source VARCHAR(50), -- 'google_maps', 'linkedin', 'apollo', 'scraping'
    source_id VARCHAR(255), -- place_id, profile_url, apollo_id

    -- Lead Scoring (Prospect job)
    lead_score INTEGER DEFAULT 0, -- 0-100
    fit_score INTEGER, -- product fit
    intent_score INTEGER, -- buying intent
    enrichment_data JSONB, -- Apollo data, tech stack, etc

    -- Workflow State Machine
    stage VARCHAR(50) DEFAULT 'prospected',
    -- 'prospected' ‚Üí 'sdr_outreach' ‚Üí 'meeting_booked' ‚Üí 'proposal_sent' ‚Üí 'closed_won' / 'closed_lost'

    -- SDR Tracking
    outreach_started_at TIMESTAMP,
    last_touch_at TIMESTAMP,
    touch_count INTEGER DEFAULT 0,
    replied BOOLEAN DEFAULT FALSE,
    reply_sentiment VARCHAR(20), -- 'positive', 'neutral', 'negative', 'objection'
    meeting_booked BOOLEAN DEFAULT FALSE,
    meeting_date TIMESTAMP,

    -- Closer Tracking
    proposal_sent_at TIMESTAMP,
    proposal_value DECIMAL(10,2),
    objection_type VARCHAR(50), -- 'price', 'timing', 'authority', 'need', 'trust'
    contract_sent BOOLEAN DEFAULT FALSE,
    closed_at TIMESTAMP,
    closed_value DECIMAL(10,2),

    -- Metadata
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    assigned_to VARCHAR(100) -- 'prospect_wf', 'sdr_wf', 'closer_wf'
);

-- Indexes for performance
CREATE INDEX idx_stage ON leads(stage);
CREATE INDEX idx_lead_score ON leads(lead_score DESC);
CREATE INDEX idx_outreach_started ON leads(outreach_started_at);
CREATE INDEX idx_source ON leads(source);
```

### Estado de Lead (State Machine)

Cada workflow √© respons√°vel por transicionar o lead de um estado para outro:

```
PROSPECT WF: null ‚Üí 'prospected' (quando lead √© inserido + scored)
SDR WF:      'prospected' ‚Üí 'sdr_outreach' (quando primeiro email enviado)
             'sdr_outreach' ‚Üí 'meeting_booked' (quando reuni√£o agendada)
CLOSER WF:   'meeting_booked' ‚Üí 'proposal_sent' (quando proposta enviada)
             'proposal_sent' ‚Üí 'closed_won' (quando fechou venda)
             'proposal_sent' ‚Üí 'closed_lost' (quando perdeu venda)
```

---

## üîç Workflow 1: Prospect Architecture

**Responsabilidade:** Coletar, enriquecer, qualificar e inserir leads no database.

### High-Level Flow

```
[Cron: Daily 8am] ‚Üí [Google Maps Scrape] ‚Üí [Apollo Enrich] ‚Üí
[GPT-4 Lead Score] ‚Üí [PostgreSQL Insert] ‚Üí [Update stage = 'prospected']
```

### n8n Nodes (Simplified)

```json
{
  "nodes": [
    {
      "name": "Daily Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "parameters": {
        "rule": { "interval": [{ "field": "cronExpression", "expression": "0 8 * * *" }] }
      }
    },
    {
      "name": "Google Maps Scrape",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "url": "https://api.outscraper.com/maps/search-v3",
        "method": "POST",
        "bodyParameters": {
          "query": "marketing agency in S√£o Paulo",
          "limit": 100
        }
      }
    },
    {
      "name": "Extract Company Data",
      "type": "n8n-nodes-base.function",
      "parameters": {
        "functionCode": "const places = $input.all()[0].json.data;\n\nreturn places.map(place => ({\n  json: {\n    name: place.name,\n    email: place.emails?.[0] || null,\n    phone: place.phone,\n    website: place.site,\n    source: 'google_maps',\n    source_id: place.place_id,\n    company: place.name\n  }\n}));"
      }
    },
    {
      "name": "Apollo Enrich",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "url": "https://api.apollo.io/v1/people/match",
        "method": "POST",
        "authentication": "headerAuth",
        "bodyParameters": {
          "organization_name": "={{ $json.company }}",
          "email": "={{ $json.email }}"
        }
      }
    },
    {
      "name": "GPT-4 Lead Scoring",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "parameters": {
        "model": "gpt-4",
        "prompt": "Score this lead 0-100 based on:\n- Company size: {{ $json.employees }}\n- Industry fit: {{ $json.industry }}\n- Tech stack: {{ $json.technologies }}\n- Website quality: {{ $json.website }}\n\nOutput JSON: { \"lead_score\": 85, \"fit_score\": 90, \"intent_score\": 80, \"reasoning\": \"...\" }"
      }
    },
    {
      "name": "Insert to PostgreSQL",
      "type": "n8n-nodes-base.postgres",
      "parameters": {
        "operation": "insert",
        "table": "leads",
        "columns": "email, name, company, phone, source, source_id, lead_score, fit_score, intent_score, enrichment_data, stage, assigned_to",
        "returnFields": "*"
      }
    },
    {
      "name": "Send to Redis Cache",
      "type": "n8n-nodes-base.redis",
      "parameters": {
        "operation": "set",
        "key": "lead:{{ $json.id }}",
        "value": "={{ JSON.stringify($json) }}",
        "ttl": 86400
      }
    }
  ]
}
```

### Key Design Decisions

1. **Idempotency**: Check if `email` already exists before inserting (use `ON CONFLICT DO NOTHING`)
2. **Batch Processing**: Process 100 leads at a time (not 1.500 at once)
3. **Error Handling**: Failed enrichment? Still insert lead with `enrichment_data = null`
4. **Logging**: Every insert logs to `workflow_logs` table

---

## üìß Workflow 2: SDR Architecture

**Responsabilidade:** Pegar leads qualificados (`stage = 'prospected'`) e fazer outreach at√© agendar reuni√£o.

### High-Level Flow

```
[Cron: Every hour] ‚Üí [Query DB: stage='prospected' AND lead_score > 70] ‚Üí
[GPT-4 Email Personalization] ‚Üí [Send Email] ‚Üí [Track in DB] ‚Üí
[Wait 2 days] ‚Üí [Follow-up Email] ‚Üí ... ‚Üí [Meeting booked? Update stage]
```

### n8n Nodes (Simplified)

```json
{
  "nodes": [
    {
      "name": "Hourly Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "parameters": {
        "rule": { "interval": [{ "field": "hours", "hoursInterval": 1 }] }
      }
    },
    {
      "name": "Query Qualified Leads",
      "type": "n8n-nodes-base.postgres",
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM leads WHERE stage = 'prospected' AND lead_score > 70 AND outreach_started_at IS NULL LIMIT 50"
      }
    },
    {
      "name": "GPT-4 Email Generator",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "parameters": {
        "model": "gpt-4",
        "prompt": "Write a personalized cold email for:\nCompany: {{ $json.company }}\nIndustry: {{ $json.enrichment_data.industry }}\nPain point: Low lead gen\n\nTone: Casual, Brazilian Portuguese\nLength: 80 words max\nCTA: Book 15-min call"
      }
    },
    {
      "name": "Send Email via Gmail",
      "type": "n8n-nodes-base.gmail",
      "parameters": {
        "operation": "send",
        "to": "={{ $json.email }}",
        "subject": "{{ $json.email_subject }}",
        "body": "={{ $json.email_body }}"
      }
    },
    {
      "name": "Update DB: Outreach Started",
      "type": "n8n-nodes-base.postgres",
      "parameters": {
        "operation": "update",
        "table": "leads",
        "updateKey": "id",
        "columns": "stage, outreach_started_at, touch_count, assigned_to",
        "values": "'sdr_outreach', NOW(), 1, 'sdr_wf'"
      }
    },
    {
      "name": "Wait 2 Days",
      "type": "n8n-nodes-base.wait",
      "parameters": {
        "unit": "days",
        "amount": 2
      }
    },
    {
      "name": "Check Reply (Gmail API)",
      "type": "n8n-nodes-base.gmail",
      "parameters": {
        "operation": "search",
        "q": "from:{{ $json.email }} after:{{ $json.outreach_started_at }}"
      }
    },
    {
      "name": "If Reply ‚Üí Route",
      "type": "n8n-nodes-base.if",
      "parameters": {
        "conditions": {
          "boolean": [{ "value1": "={{ $json.messages.length }}", "operation": "larger", "value2": 0 }]
        }
      }
    },
    {
      "name": "GPT-4 Reply Sentiment",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "parameters": {
        "model": "gpt-4",
        "prompt": "Classify this email reply sentiment:\n\n{{ $json.messages[0].body }}\n\nOutput JSON: { \"sentiment\": \"positive\", \"meeting_intent\": true, \"objection\": null }"
      }
    },
    {
      "name": "If Positive ‚Üí Book Meeting",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "url": "https://api.calendly.com/scheduled_events",
        "method": "POST"
      }
    }
  ]
}
```

### Key Design Decisions

1. **Rate Limiting**: Only 50 leads/hour to avoid Gmail spam detection
2. **Smart Follow-ups**: Check Redis cache for lead state before sending next touch
3. **Reply Detection**: Poll Gmail every hour for replies, classify with GPT-4
4. **Meeting Booking**: Auto-send Calendly link if reply sentiment = 'positive'

---

## ü§ù Workflow 3: Closer Architecture

**Responsabilidade:** Pegar leads com reuni√£o agendada (`stage = 'meeting_booked'`) e fechar venda.

### High-Level Flow

```
[Webhook: Meeting completed] ‚Üí [Send thank you + proposal] ‚Üí
[Wait 1 day] ‚Üí [Follow-up] ‚Üí [Detect objection] ‚Üí
[GPT-4 Objection Handler] ‚Üí [Send contract via DocuSign] ‚Üí [Update stage = 'closed_won']
```

### n8n Nodes (Simplified)

```json
{
  "nodes": [
    {
      "name": "Webhook: Meeting Ended",
      "type": "n8n-nodes-base.webhook",
      "parameters": {
        "path": "meeting-completed",
        "httpMethod": "POST"
      }
    },
    {
      "name": "Query Lead from DB",
      "type": "n8n-nodes-base.postgres",
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT * FROM leads WHERE email = '{{ $json.email }}'"
      }
    },
    {
      "name": "GPT-4 Proposal Generator",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "parameters": {
        "model": "gpt-4",
        "prompt": "Generate a proposal for:\n- Company: {{ $json.company }}\n- Discussed problem: {{ $json.meeting_notes }}\n- Proposed solution: AI Sales Machine\n- Value: R$ 5.000/m√™s\n- ROI: +R$ 40k receita + R$ 18k economia = R$ 58k/m√™s\n\nOutput: Professional proposal in Portuguese (500 words)"
      }
    },
    {
      "name": "Send Proposal Email",
      "type": "n8n-nodes-base.gmail",
      "parameters": {
        "operation": "send",
        "to": "={{ $json.email }}",
        "subject": "Proposta: AI Sales Machine para {{ $json.company }}",
        "body": "={{ $json.proposal_text }}"
      }
    },
    {
      "name": "Update DB: Proposal Sent",
      "type": "n8n-nodes-base.postgres",
      "parameters": {
        "operation": "update",
        "table": "leads",
        "columns": "stage, proposal_sent_at, proposal_value",
        "values": "'proposal_sent', NOW(), 5000"
      }
    },
    {
      "name": "Wait 1 Day",
      "type": "n8n-nodes-base.wait",
      "parameters": { "amount": 1, "unit": "days" }
    },
    {
      "name": "Check Reply",
      "type": "n8n-nodes-base.gmail",
      "parameters": {
        "operation": "search",
        "q": "from:{{ $json.email }} subject:Proposta"
      }
    },
    {
      "name": "GPT-4 Objection Classifier",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "parameters": {
        "model": "gpt-4",
        "prompt": "Classify objection:\n\n{{ $json.reply_body }}\n\nCategories: PRICE, TIMING, AUTHORITY, NEED, TRUST, POSITIVE\n\nOutput JSON: { \"objection_type\": \"PRICE\", \"auto_response\": \"...\" }"
      }
    },
    {
      "name": "If PRICE ‚Üí Send ROI Calculator",
      "type": "n8n-nodes-base.gmail",
      "parameters": {
        "body": "Entendo a preocupa√ß√£o com investimento.\n\nVeja o ROI:\n- Custo: R$ 5k/m√™s\n- Retorno: R$ 58k/m√™s\n- ROI: 1.060%\n- Payback: 3 dias\n\nQuer agendar 10 min para mostrar a calculadora?"
      }
    },
    {
      "name": "If Positive ‚Üí Send Contract",
      "type": "n8n-nodes-base.httpRequest",
      "parameters": {
        "url": "https://api.docusign.com/v2.1/accounts/{accountId}/envelopes",
        "method": "POST",
        "body": {
          "emailSubject": "Contrato - AI Sales Machine",
          "documents": [{ "documentBase64": "={{ $json.contract_pdf }}" }]
        }
      }
    },
    {
      "name": "Update DB: Closed Won",
      "type": "n8n-nodes-base.postgres",
      "parameters": {
        "operation": "update",
        "table": "leads",
        "columns": "stage, closed_at, closed_value, contract_sent",
        "values": "'closed_won', NOW(), {{ $json.proposal_value }}, true"
      }
    }
  ]
}
```

### Key Design Decisions

1. **Webhook Trigger**: Calendly sends webhook when meeting ends
2. **Auto-Proposal**: GPT-4 generates proposal based on meeting notes
3. **Objection Handling**: Max 3 objection responses before escalating to human
4. **Contract Automation**: DocuSign for e-signature (deals < R$ 10k)
5. **Human Escalation**: If `objection_type = 'COMPLEX'` or deal > R$ 10k, notify human

---

## üîó Comunica√ß√£o Entre Workflows

### M√©todo 1: Database Polling (Recommended)

Cada workflow faz **query no PostgreSQL** para pegar leads no stage certo:

```sql
-- PROSPECT WF: N√£o precisa ler (s√≥ escreve)

-- SDR WF: L√™ leads qualificados
SELECT * FROM leads
WHERE stage = 'prospected'
AND lead_score > 70
AND outreach_started_at IS NULL
ORDER BY lead_score DESC
LIMIT 50;

-- CLOSER WF: L√™ leads com reuni√£o
SELECT * FROM leads
WHERE stage = 'meeting_booked'
AND meeting_date < NOW()
AND proposal_sent_at IS NULL;
```

**Vantagens:**
- ‚úÖ Simples de implementar
- ‚úÖ Workflows desacoplados
- ‚úÖ F√°cil de debugar (s√≥ olhar o DB)

**Desvantagens:**
- ‚ùå Lat√™ncia (precisa esperar pr√≥ximo cron)
- ‚ùå Polling constante (carga no DB)

### M√©todo 2: Webhooks Internos (Advanced)

Workflow 1 chama webhook do Workflow 2 quando lead fica pronto:

```javascript
// No final do PROSPECT WF:
await $http.request({
  url: 'https://seu-n8n.com/webhook/sdr-start',
  method: 'POST',
  body: {
    lead_id: $json.id,
    email: $json.email,
    lead_score: $json.lead_score
  }
});
```

**Vantagens:**
- ‚úÖ Tempo real (sem lat√™ncia)
- ‚úÖ Menos carga no DB

**Desvantagens:**
- ‚ùå Acoplamento entre workflows
- ‚ùå Mais complexo de debugar

### M√©todo 3: Redis Pub/Sub (Expert)

Workflows publicam eventos no Redis, outros workflows subscrevem:

```javascript
// PROSPECT WF: Publica evento
await $redis.publish('leads:qualified', JSON.stringify({
  lead_id: $json.id,
  email: $json.email,
  score: $json.lead_score
}));

// SDR WF: Subscribe
$redis.subscribe('leads:qualified', (message) => {
  const lead = JSON.parse(message);
  // Start outreach workflow
});
```

**Vantagens:**
- ‚úÖ Desacoplamento total
- ‚úÖ Escal√°vel (m√∫ltiplos consumers)
- ‚úÖ Tempo real

**Desvantagens:**
- ‚ùå Complexidade (precisa gerenciar subscriptions)
- ‚ùå Precisa Redis configurado

**Recomenda√ß√£o para iniciantes:** Use **M√©todo 1 (Database Polling)**.

---

## üß™ Testing Strategy

### Teste Isolado de Cada Workflow

**PROSPECT WF:**
```bash
# Trigger manual com 1 empresa fake
curl -X POST https://seu-n8n.com/webhook/test-prospect \
  -d '{"company": "Acme Corp", "email": "test@acme.com"}'

# Verificar se inseriu no DB
SELECT * FROM leads WHERE email = 'test@acme.com';
```

**SDR WF:**
```bash
# Inserir lead fake no DB com stage='prospected'
INSERT INTO leads (email, company, lead_score, stage)
VALUES ('test@acme.com', 'Acme', 85, 'prospected');

# Rodar workflow manualmente
# Verificar se enviou email + atualizou stage
```

**CLOSER WF:**
```bash
# Inserir lead fake com stage='meeting_booked'
UPDATE leads SET stage = 'meeting_booked', meeting_date = NOW()
WHERE email = 'test@acme.com';

# Trigger webhook de meeting completed
curl -X POST https://seu-n8n.com/webhook/meeting-completed \
  -d '{"email": "test@acme.com"}'
```

### Teste End-to-End

1. Inserir 1 empresa real no Google Maps
2. Esperar PROSPECT WF processar (check DB)
3. Esperar SDR WF enviar email (check Gmail sent)
4. Simular reply positivo
5. Verificar se agendou reuni√£o
6. Simular meeting completed webhook
7. Verificar se enviou proposta
8. Simular aceita√ß√£o
9. Verificar se enviou contrato
10. Verificar `stage = 'closed_won'` no DB

**Tempo esperado:** 7-10 dias (por causa dos `Wait` nodes)

**Dica:** Use `Wait` de 1 minuto em vez de 2 dias para testes.

---

## ‚úÖ Entreg√°vel Pr√°tico

Ao final desta aula, voc√™ ter√°:

```
n8n-workflows/
‚îú‚îÄ‚îÄ 1-prospect-workflow.json       (coletar + qualificar leads)
‚îú‚îÄ‚îÄ 2-sdr-workflow.json            (outreach + agendar reuni√£o)
‚îú‚îÄ‚îÄ 3-closer-workflow.json         (proposta + fechar venda)
‚îî‚îÄ‚îÄ database-schema.sql            (PostgreSQL tables)
```

### Como Importar no n8n

1. n8n ‚Üí **Workflows** ‚Üí **Import from File**
2. Selecionar `1-prospect-workflow.json`
3. Conectar credenciais (Google Maps API, Apollo, OpenAI, Gmail, PostgreSQL)
4. Ativar workflow
5. Repetir para workflows 2 e 3

---

## üéØ Checklist de Valida√ß√£o

Antes de prosseguir, valide:

- [ ] **PostgreSQL database criado** com tabela `leads` e indexes
- [ ] **Workflow 1 (Prospect)** importado e credenciais conectadas
- [ ] **Workflow 2 (SDR)** importado e credenciais conectadas
- [ ] **Workflow 3 (Closer)** importado e credenciais conectadas
- [ ] **Teste isolado:** Inserir 1 lead fake, verificar se aparece no DB
- [ ] **Teste SDR:** Lead com `stage='prospected'` recebe email?
- [ ] **Teste Closer:** Lead com `stage='meeting_booked'` recebe proposta?
- [ ] **Monitoring:** Dashboard mostrando leads em cada stage

---

## üöÄ Pr√≥ximos Passos

**Agora que tem a arquitetura modular:**

1. **Aula 2.3** ‚Üí Configurar Prospec√ß√£o Google Maps (detalhes do Workflow 1)
2. **Aula 2.4** ‚Üí Configurar Prospec√ß√£o LinkedIn + Phantom Buster
3. **Aula 2.5** ‚Üí Apollo Search & Enrich (enriquecer leads do Google Maps)
4. **Aula 2.6** ‚Üí Lead Scoring Inteligente (GPT-4 advanced scoring)

---

## üìö Recursos Adicionais

- [n8n Sub-Workflows Documentation](https://docs.n8n.io/workflows/sub-workflows/)
- [PostgreSQL State Machine Pattern](https://www.postgresql.org/docs/current/sql-update.html)
- [Redis Pub/Sub Tutorial](https://redis.io/topics/pubsub)
- [n8n Error Handling Best Practices](https://docs.n8n.io/workflows/error-handling/)

---

**üéì Conceito-chave:** Workflows modulares > Workflows monol√≠ticos. Separe responsabilidades, use database como ponto de comunica√ß√£o, e teste cada workflow isoladamente.
