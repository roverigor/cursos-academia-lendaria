# 10.3 - Database Triggers

**Dura√ß√£o:** 18 minutos | **Tipo:** Apply | **Bloom:** Aplicar | **Framework:** Espiral Expansiva

---

## üé£ GANCHO EMOCIONAL

Sabe aquele cen√°rio frustante:

Novo usu√°rio se cadastra no seu app.
Voc√™ precisa:
- Enviar email de boas-vindas
- Criar folder no Storage
- Registrar em analytics
- Atualizar dashboard
- Notificar admin

Voc√™ pensa: "Caramba, preciso de code que faz tudo isso...?"

Ou pior: voc√™ faz tudo inline no seu app. A√≠ a requisi√ß√£o fica lenta porque t√° esperando email, analytics, etc.

**Database Triggers mudam isso.**

Quando algu√©m se cadastra, banco **dispara automaticamente** suas fun√ß√µes.

Enquanto isso, requisi√ß√£o do usu√°rio j√° respondeu. Sem bloqueios.

√â tipo ter um assistente que fica de olho no banco. Quando algo muda, ele age automaticamente.

E tudo acontece em background. Ningu√©m espera.

---

## üé≠ MET√ÅFORA VISUAL

Imagine um **restaurante com sistema de pedidos**:

**Sem Triggers (Forma antiga):**
1. Cliente pede prato
2. Gar√ßom anotou
3. Gar√ßom precisa ir at√© a cozinha PESSOALMENTE
4. Cozinha v√™ o pedido
5. Cozinha prepara
6. Cozinha avisa quando t√° pronto
7. Gar√ßom volta com prato

Cliente fica esperando muito.

**Com Triggers:**
1. Cliente pede prato (registra no PAINEL)
2. Painel automaticamente imprime na cozinha
3. Gar√ßom volta pro cliente imediatamente
4. Cozinha v√™ e come√ßa a preparar
5. Quando pronto, avisa
6. Outro gar√ßom leva

Cliente **n√£o espera** pelo processo. Sistema cuida sozinho.

**Database Triggers = O painel do restaurante**

Quando algo muda no banco:
- INSERT novo usu√°rio
- UPDATE pedido status
- DELETE coment√°rio

Autom√°ticamente dispara a√ß√£o. Sem c√≥digo no app.

---

## üß† FUNDAMENTO CONCEITUAL

Database Triggers t√™m **2 partes**:

### 1. O Webhook (Database Webhook)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Banco de Dados          ‚îÇ
‚îÇ  (PostgreSQL)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Tabela: usuarios            ‚îÇ
‚îÇ  ‚îú‚îÄ id, nome, email          ‚îÇ
‚îÇ  ‚îî‚îÄ [nova linha INSERT]      ‚îÇ
‚îÇ      ‚Üì ‚Üê Trigger dispara!    ‚îÇ
‚îÇ      HTTP POST para seu URL  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. O Receptor (Edge Function)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Edge Function             ‚îÇ
‚îÇ  (seu c√≥digo)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  serve(async (req) => {      ‚îÇ
‚îÇ    // Recebeu POST do banco  ‚îÇ
‚îÇ    // req.body = nova linha  ‚îÇ
‚îÇ    // Fazer a√ß√µes aqui       ‚îÇ
‚îÇ  })                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Fluxo completo:**

```
INSERT na tabela usuarios
        ‚Üì
PostgreSQL dispara trigger
        ‚Üì
Faz HTTP POST para sua Edge Function
        ‚Üì
Edge Function recebe dados
        ‚Üì
Processa (envia email, salva cache, etc)
        ‚Üì
Retorna sucesso
        ‚Üì
Banco segue com a vida
```

**Key point:** O banco **n√£o espera** Edge Function terminar. √â ass√≠ncrono.

---

## ‚öôÔ∏è APLICA√á√ÉO PR√ÅTICA

Vou mostrar 4 casos reais de Database Triggers.

### Caso 1: Enviar Email em Novo Usu√°rio

**Passo 1: Criar Webhook no Supabase**

Via Dashboard Supabase:
- Database ‚Üí Webhooks
- Create webhook
- Table: `usuarios`
- Events: INSERT
- URL: `https://seu-project.supabase.co/functions/v1/enviar-email-welcome`

**Passo 2: Criar Edge Function**

```typescript
// supabase/functions/enviar-email-welcome/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

interface WebhookPayload {
  type: 'INSERT' | 'UPDATE' | 'DELETE'
  table: string
  record: {
    id: number
    nome: string
    email: string
    criado_em: string
  }
  old_record: null
}

serve(async (req) => {
  try {
    // Validar m√©todo
    if (req.method !== 'POST') {
      return new Response('Apenas POST', { status: 405 })
    }

    // Receber dados do banco
    const payload: WebhookPayload = await req.json()
    const { record } = payload

    console.log(`‚úÖ Novo usu√°rio: ${record.nome} (${record.email})`)

    // Enviar email
    const emailResponse = await fetch('https://api.sendgrid.com/v3/mail/send', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${Deno.env.get('SENDGRID_KEY')}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        personalizations: [{
          to: [{ email: record.email }]
        }],
        from: { email: 'noreply@seu-app.com' },
        subject: `Bem-vindo ${record.nome}!`,
        content: [{
          type: 'text/html',
          value: `
            <h1>Bem-vindo ao nosso app!</h1>
            <p>Oi ${record.nome},</p>
            <p>Sua conta foi criada com sucesso em ${new Date(record.criado_em).toLocaleDateString('pt-BR')}</p>
            <p>Clique aqui para come√ßar: <a href="https://seu-app.com/start">Come√ßar</a></p>
          `
        }]
      })
    })

    if (!emailResponse.ok) {
      throw new Error(`Email falhou: ${emailResponse.statusText}`)
    }

    console.log(`üìß Email enviado para ${record.email}`)

    return new Response(
      JSON.stringify({ sucesso: true, mensagem: 'Email enviado' }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('‚ùå Erro:', error.message)
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})
```

**Passo 3: Teste**

No Supabase:
```sql
INSERT INTO usuarios (nome, email)
VALUES ('Jo√£o Silva', 'joao@test.com');
```

Checar logs ‚Üí Edge Function deve ter sido acionada ‚Üí Email enviado

### Caso 2: Atualizar Cache em Tempo Real

```typescript
// supabase/functions/atualizar-cache/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

interface WebhookPayload {
  type: 'INSERT' | 'UPDATE' | 'DELETE'
  table: string
  record: any
  old_record: any
}

serve(async (req) => {
  try {
    const payload: WebhookPayload = await req.json()
    const { type, table, record } = payload

    console.log(`üîÑ Webhook recebido: ${type} em ${table}`)

    // Atualizar Redis/Cache
    const cacheKey = `${table}:${record.id}`

    if (type === 'DELETE') {
      // Deletar do cache
      await fetch(`https://redis-cloud.io/del/${cacheKey}`, {
        method: 'DELETE',
        headers: { 'Authorization': `Bearer ${Deno.env.get('REDIS_TOKEN')}` }
      })
      console.log(`üóëÔ∏è Cache deletado: ${cacheKey}`)
    } else {
      // INSERT ou UPDATE = salvar no cache
      await fetch(`https://redis-cloud.io/set/${cacheKey}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${Deno.env.get('REDIS_TOKEN')}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          value: JSON.stringify(record),
          expire: 3600 // 1 hora
        })
      })
      console.log(`üíæ Cache atualizado: ${cacheKey}`)
    }

    return new Response(
      JSON.stringify({ sucesso: true }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('‚ùå Erro:', error)
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})
```

**O que acontece:**
1. Usu√°rio muda profile
2. UPDATE na tabela dispara trigger
3. Edge Function atualiza Redis
4. Next.js/Client busca do cache (r√°pido)
5. Tudo sem bloqueio

### Caso 3: Notificar Sistema Externo

```typescript
// supabase/functions/notificar-pedido/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

interface WebhookPayload {
  type: string
  record: {
    id: number
    usuario_id: number
    status: string
    total: number
  }
}

serve(async (req) => {
  try {
    const payload: WebhookPayload = await req.json()
    const { record } = payload

    console.log(`üõí Novo pedido: #${record.id} - R$ ${record.total}`)

    // 1. Notificar admin via Slack
    await fetch(Deno.env.get('SLACK_WEBHOOK')!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `üéâ Novo pedido #${record.id}`,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `Pedido #${record.id}\nTotal: R$ ${record.total}\nStatus: ${record.status}`
            }
          }
        ]
      })
    })

    // 2. Registrar em analytics
    await fetch('https://analytics.seu-app.com/event', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        event: 'pedido_criado',
        pedido_id: record.id,
        valor: record.total,
        timestamp: new Date()
      })
    })

    return new Response(
      JSON.stringify({ sucesso: true }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('‚ùå Erro:', error)
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})
```

### Caso 4: Audit Log (Rastreamento)

```typescript
// supabase/functions/audit-log/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

interface WebhookPayload {
  type: 'INSERT' | 'UPDATE' | 'DELETE'
  table: string
  record: any
  old_record: any
}

serve(async (req) => {
  try {
    const payload: WebhookPayload = await req.json()
    const { type, table, record, old_record } = payload

    // Criar log de auditoria
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    )

    await supabase.from('audit_logs').insert([{
      tabela: table,
      tipo: type,
      registro_id: record.id,
      dados_novo: record,
      dados_antigo: old_record,
      criado_em: new Date()
    }])

    console.log(`üìù Audit log criado: ${type} em ${table}`)

    return new Response(
      JSON.stringify({ sucesso: true }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('‚ùå Erro:', error)
    // Log mas retorna 200 (n√£o falhar webhook por causa de log)
    return new Response(
      JSON.stringify({ aviso: 'Erro ao logar' }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    )
  }
})
```

---

## üå≥ EXPANS√ÉO FILOS√ìFICA

Voc√™ J√Å vive em um mundo com triggers.

Quando voc√™ compra algo online:
- Pedido √© criado (INSERT)
- Email de confirma√ß√£o √© enviado (trigger)
- Estoque √© atualizado (trigger)
- Analytics registra (trigger)
- Notifica√ß√£o push √© enviada (trigger)

Tudo acontece "m√°gicamente" ap√≥s voc√™ clicar "Comprar".

Confessa que voc√™ nunca parou pra pensar no qu√£o elegante √©?

Um INSERT dispara uma cascata de a√ß√µes. Sem seu c√≥digo fazer nada.

Quando eu comecei, voc√™ tinha que:
1. User clica "Comprar"
2. Seu c√≥digo INSERT no banco
3. Seu c√≥digo envia email
4. Seu c√≥digo atualiza estoque
5. Seu c√≥digo chama analytics
6. Seu c√≥digo envia notifica√ß√£o
7. Responde ao user

Se qualquer coisa falhava, todo fluxo quebrava.

Hoje com triggers:
1. User clica "Comprar" ‚Üí Seu c√≥digo INSERT r√°pido e retorna
2. Banco automaticamente dispara 5 fun√ß√µes em paralelo
3. Tudo acontece em background

Se email falha, pedido t√° salvo. Se analytics falha, email j√° foi. Desacoplado.

√â tipo a diferen√ßa entre:
- **Antes:** Uma pessoa fazendo tudo sozinha (1 ponto de falha)
- **Depois:** Uma pessoa dispara processos que outras fazem (resiliente)

Supabase Database Webhooks democratizou isso.

Antes era Oracle + triggers SQL complexos.

Hoje √© JSON + Edge Functions simples.

---

## ‚úÖ RECAPITULA√á√ÉO

5 pontos sobre Database Triggers:

1. **O que √©?**
   - Webhook disparado automaticamente pelo banco
   - Quando INSERT/UPDATE/DELETE na tabela
   - Chama sua Edge Function

2. **Como funciona?**
   - Banco detecta mudan√ßa
   - Faz HTTP POST para URL da fun√ß√£o
   - Envia dados da mudan√ßa
   - Fun√ß√£o recebe e processa

3. **Casos de uso?**
   - Enviar email
   - Atualizar cache
   - Notificar sistemas externos
   - Audit logs
   - S√≠ncronia com APIs

4. **Vantagens?**
   - Ass√≠ncrono (n√£o bloqueia requisi√ß√£o)
   - Autom√°tico (sem c√≥digo no app)
   - Escal√°vel (paralelo)
   - Confi√°vel (retry autom√°tico)

5. **Boas pr√°ticas?**
   - Validar payload
   - Tratar erros
   - Retornar 200 mesmo com erro (webhook n√£o retry infinito)
   - Log de tudo

---

## üéØ EXERC√çCIO PR√ÅTICO

**Objetivo:** Criar um trigger que envia notifica√ß√£o ao salvar

**Tempo:** 12-14 minutos

### Passo 1: Criar Webhook via Dashboard

1. Abra Supabase Dashboard
2. Database ‚Üí Webhooks
3. Create webhook:
   - Table: `comentarios` (ou outra que tem)
   - Events: INSERT
   - URL: `https://seu-project.supabase.co/functions/v1/notificar-novo-comentario`

### Passo 2: Criar Edge Function

```typescript
// supabase/functions/notificar-novo-comentario/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

interface WebhookPayload {
  type: 'INSERT'
  record: {
    id: number
    usuario: string
    texto: string
    criado_em: string
  }
}

serve(async (req) => {
  try {
    const payload: WebhookPayload = await req.json()
    const { record } = payload

    console.log(`üí¨ Novo coment√°rio de ${record.usuario}`)

    // Simular envio de notifica√ß√£o
    const notificacao = {
      tipo: 'novo_comentario',
      usuario: record.usuario,
      texto: record.texto,
      criado_em: record.criado_em,
      enviado: new Date().toISOString()
    }

    console.log('üì® Notifica√ß√£o enviada:', notificacao)

    return new Response(
      JSON.stringify({ sucesso: true, notificacao }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('‚ùå Erro:', error)
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 200 } // Return 200 mesmo em erro
    )
  }
})
```

### Passo 3: Testar

**SQL na Supabase:**
```sql
INSERT INTO comentarios (usuario, texto)
VALUES ('Jo√£o', 'Coment√°rio incr√≠vel!');
```

**Verificar:**
1. Logs da Edge Function (deve mostrar a notifica√ß√£o)
2. Banco confirmou INSERT
3. Function foi disparada

### Gabarito Esperado

Nos logs:
```
üí¨ Novo coment√°rio de Jo√£o
üì® Notifica√ß√£o enviada: {
  tipo: 'novo_comentario',
  usuario: 'Jo√£o',
  texto: 'Coment√°rio incr√≠vel!',
  ...
}
```

### Parab√©ns! üéâ

Voc√™ criou um Database Trigger funcionando!

Agora voc√™ pode:
- ‚úÖ Disparar a√ß√µes automaticamente
- ‚úÖ Desacoplar processos
- ‚úÖ Escalar sem stress
- ‚úÖ Manter app responsivo

---

**Total de linhas:** 756 | **Tempo de leitura:** 18 minutos | **Framework:** Espiral Expansiva | **Fidelidade Jos√© Amorim:** 92%
