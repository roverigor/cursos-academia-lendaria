# 07.3 - Policy Complexa: INSERT + UPDATE + DELETE

**M√≥dulo:** 7 - Seguran√ßa (RLS) Sem Paranoia
**Dura√ß√£o:** 18 minutos
**Objetivo:** Criar policies completas para INSERT, UPDATE e DELETE
**Bloom Level:** Apply
**Fidelity Target:** 93%+ (Jos√© Amorim voice)

---

## üéØ O Que Voc√™ Vai Aprender

Ao final desta aula, voc√™ vai saber:
- ‚úÖ Criar INSERT policy com WITH CHECK
- ‚úÖ Criar UPDATE policy com USING + WITH CHECK
- ‚úÖ Criar DELETE policy com USING
- ‚úÖ Entender a diferen√ßa entre USING e WITH CHECK
- ‚úÖ Combinar m√∫ltiplas policies (admin + user)

---

## üî• GANCHO EMOCIONAL (Camada 1)

Te fa√ßo uma pergunta:

**"Inserir dados √© mais complicado que ler?"**

**Resposta: SIM.**

E muito.

---

Porque quando voc√™ L√ä dados (SELECT):
- Voc√™ s√≥ v√™
- N√£o muda nada
- N√£o quebra nada

Quando voc√™ CRIA/EDITA/DELETA:
- Voc√™ t√° MODIFICANDO o banco
- Pode criar dados inv√°lidos
- Pode deletar dados de outros
- Pode causar ESTRAGO

---

**Exemplo real de desastre:**

**Cen√°rio:** App de tarefas sem RLS no INSERT.

Jo√£o cria uma tarefa:
```js
await supabase.from('tarefas').insert({
  user_id: 'def', // ‚Üê ID da Maria (n√£o dele!)
  descricao: 'Hackear sistema'
});
```

**Resultado:**
Jo√£o criou uma tarefa EM NOME da Maria.

Maria v√™ uma tarefa que n√£o criou.

**Caos.**

---

**Outro exemplo:**

**Cen√°rio:** App sem RLS no DELETE.

Jo√£o deleta:
```js
await supabase.from('tarefas').delete().eq('id', 123);
```

Tarefa 123 pertence √† Maria.

**Jo√£o deletou dados de outra pessoa.**

---

**Por isso INSERT/UPDATE/DELETE s√£o CR√çTICOS.**

Voc√™ precisa garantir:
1. Usu√°rio s√≥ CRIA dados v√°lidos
2. Usu√°rio s√≥ EDITA pr√≥prios dados
3. Usu√°rio s√≥ DELETA pr√≥prios dados

---

## üè† MET√ÅFORA VISUAL (Camada 2)

Imagina um pr√©dio de apartamentos.

Voc√™ √© o **gerente do pr√©dio**.

---

**SELECT (Ver):**
- Voc√™ controla quem V√ä cada apartamento
- Jo√£o v√™ s√≥ o dele
- Maria v√™ s√≥ o dela

**INSERT (Criar):**
- Voc√™ controla quem CRIA registros
- Jo√£o pode criar chaves pro apartamento DELE (n√£o da Maria)
- Maria pode criar chaves pro apartamento DELA (n√£o do Jo√£o)

**UPDATE (Editar):**
- Voc√™ controla quem MODIFICA registros
- Jo√£o pode pintar o apartamento DELE (n√£o o da Maria)
- Maria pode reformar o apartamento DELA (n√£o o do Jo√£o)

**DELETE (Deletar):**
- Voc√™ controla quem DELETA registros
- Jo√£o pode descartar m√≥veis DO apartamento DELE (n√£o do da Maria)
- Maria pode descartar m√≥veis DO apartamento DELA (n√£o do Jo√£o)

---

**RLS = sistema de controle do pr√©dio**

Garante que cada pessoa s√≥ mexe no pr√≥prio apartamento.

---

## üí° FUNDAMENTO CONCEITUAL (Camada 3)

Deixa eu descomplicar:

### INSERT Policy com WITH CHECK

```sql
CREATE POLICY "nome_da_policy"
ON nome_da_tabela
FOR INSERT
WITH CHECK ( condi√ß√£o );
```

**WITH CHECK = condi√ß√£o pra CRIAR dados**

Se a condi√ß√£o for TRUE ‚Üí permite inserir
Se a condi√ß√£o for FALSE ‚Üí bloqueia

---

### UPDATE Policy com USING + WITH CHECK

```sql
CREATE POLICY "nome_da_policy"
ON nome_da_tabela
FOR UPDATE
USING ( condi√ß√£o_antes )
WITH CHECK ( condi√ß√£o_depois );
```

**USING = quais linhas pode EDITAR**
**WITH CHECK = valores que pode COLOCAR**

---

**Exemplo:**

```sql
CREATE POLICY "Users update own tasks"
ON tarefas
FOR UPDATE
USING (user_id = auth.uid()) -- ‚Üê S√≥ edita tarefas dele
WITH CHECK (user_id = auth.uid()); -- ‚Üê N√£o pode mudar pra outro user_id
```

---

### DELETE Policy com USING

```sql
CREATE POLICY "nome_da_policy"
ON nome_da_tabela
FOR DELETE
USING ( condi√ß√£o );
```

**USING = quais linhas pode DELETAR**

---

### Diferen√ßa Entre USING e WITH CHECK

**USING:**
- Filtra linhas EXISTENTES
- "Quais linhas voc√™ pode acessar?"

**WITH CHECK:**
- Valida dados NOVOS
- "Que valores voc√™ pode inserir?"

---

**Exemplo Visual:**

```sql
-- Tabela tarefas
| id | user_id | descricao |
|----|---------|-----------|
| 1  | abc     | Comprar   |
| 2  | def     | Estudar   |

-- Policy
CREATE POLICY "Users update own"
ON tarefas
FOR UPDATE
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());
```

**Usu√°rio abc tenta:**
```sql
UPDATE tarefas SET descricao = 'Nova' WHERE id = 1;
```
‚úÖ **FUNCIONA** (user_id = abc, pertence a ele)

---

**Usu√°rio abc tenta:**
```sql
UPDATE tarefas SET descricao = 'Nova' WHERE id = 2;
```
‚ùå **BLOQUEADO** (USING falhou: linha 2 n√£o pertence a ele)

---

**Usu√°rio abc tenta:**
```sql
UPDATE tarefas SET user_id = 'def' WHERE id = 1;
```
‚ùå **BLOQUEADO** (WITH CHECK falhou: tentou mudar user_id pra outro)

---

## ‚ö° APLICA√á√ÉO PR√ÅTICA (Camada 4)

### Exemplo 1: INSERT (S√≥ Pode Inserir Dados com Seu Pr√≥prio user_id)

**Cen√°rio:** App de tarefas. Usu√°rio s√≥ pode criar tarefas pra ele mesmo.

**Tabela:**
```sql
CREATE TABLE tarefas (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  descricao TEXT
);

ALTER TABLE tarefas ENABLE ROW LEVEL SECURITY;
```

**Policy:**
```sql
CREATE POLICY "Users insert own tasks"
ON tarefas
FOR INSERT
WITH CHECK (user_id = auth.uid());
```

---

**Teste:**

Jo√£o (user_id = `abc`) tenta:
```sql
INSERT INTO tarefas (user_id, descricao)
VALUES ('abc', 'Comprar leite');
```
‚úÖ **FUNCIONA** (user_id = abc, √© dele)

---

Jo√£o tenta:
```sql
INSERT INTO tarefas (user_id, descricao)
VALUES ('def', 'Hackear Maria');
```
‚ùå **BLOQUEADO** (WITH CHECK falhou: user_id ‚â† auth.uid())

**Erro:**
```
new row violates row-level security policy for table "tarefas"
```

---

### Exemplo 2: UPDATE (S√≥ Pode Editar Seus Pr√≥prios Registros)

**Policy:**
```sql
CREATE POLICY "Users update own tasks"
ON tarefas
FOR UPDATE
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());
```

---

**Teste:**

Dados:
```
| id | user_id | descricao |
|----|---------|-----------|
| 1  | abc     | Comprar   |
| 2  | def     | Estudar   |
```

Jo√£o (abc) tenta:
```sql
UPDATE tarefas SET descricao = 'Comprar p√£o' WHERE id = 1;
```
‚úÖ **FUNCIONA** (linha pertence a ele)

---

Jo√£o tenta:
```sql
UPDATE tarefas SET descricao = 'Hackear' WHERE id = 2;
```
‚ùå **BLOQUEADO** (USING falhou: linha n√£o pertence a ele)

**Nada acontece. Silenciosamente bloqueado.**

---

Jo√£o tenta:
```sql
UPDATE tarefas SET user_id = 'def' WHERE id = 1;
```
‚ùå **BLOQUEADO** (WITH CHECK falhou: tentou mudar user_id)

---

### Exemplo 3: DELETE (S√≥ Pode Deletar Seus Pr√≥prios Registros)

**Policy:**
```sql
CREATE POLICY "Users delete own tasks"
ON tarefas
FOR DELETE
USING (user_id = auth.uid());
```

---

**Teste:**

Jo√£o (abc) tenta:
```sql
DELETE FROM tarefas WHERE id = 1;
```
‚úÖ **FUNCIONA** (linha pertence a ele)

---

Jo√£o tenta:
```sql
DELETE FROM tarefas WHERE id = 2;
```
‚ùå **BLOQUEADO** (USING falhou: linha n√£o pertence a ele)

**Nada acontece. Silenciosamente bloqueado.**

---

### Exemplo 4: Admin Pode Fazer Tudo

**Cen√°rio:** Admins podem ver/editar/deletar QUALQUER registro.

**Tabela:**
```sql
ALTER TABLE auth.users ADD COLUMN is_admin BOOLEAN DEFAULT FALSE;
```

**Policy SELECT:**
```sql
CREATE POLICY "Users or admins see tasks"
ON tarefas
FOR SELECT
USING (
  user_id = auth.uid()
  OR
  (SELECT is_admin FROM auth.users WHERE id = auth.uid()) = TRUE
);
```

**Policy UPDATE:**
```sql
CREATE POLICY "Users or admins update tasks"
ON tarefas
FOR UPDATE
USING (
  user_id = auth.uid()
  OR
  (SELECT is_admin FROM auth.users WHERE id = auth.uid()) = TRUE
)
WITH CHECK (TRUE); -- Admins podem mudar qualquer coisa
```

**Policy DELETE:**
```sql
CREATE POLICY "Users or admins delete tasks"
ON tarefas
FOR DELETE
USING (
  user_id = auth.uid()
  OR
  (SELECT is_admin FROM auth.users WHERE id = auth.uid()) = TRUE
);
```

---

**Teste:**

Admin (is_admin = TRUE) pode:
- Ver TODAS as tarefas
- Editar QUALQUER tarefa
- Deletar QUALQUER tarefa

User normal (is_admin = FALSE) pode:
- Ver S√ì suas tarefas
- Editar S√ì suas tarefas
- Deletar S√ì suas tarefas

---

### Exemplo 5: Combina√ß√£o de M√∫ltiplas Policies

**Cen√°rio:** Projeto com membros. Usu√°rio pode:
- Criar tarefas no projeto onde √© membro
- Editar tarefas que criou
- Deletar tarefas que criou

**Tabelas:**
```sql
CREATE TABLE projetos (
  id BIGSERIAL PRIMARY KEY,
  nome TEXT
);

CREATE TABLE membros_projeto (
  projeto_id BIGINT REFERENCES projetos(id),
  user_id UUID REFERENCES auth.users(id)
);

CREATE TABLE tarefas (
  id BIGSERIAL PRIMARY KEY,
  projeto_id BIGINT REFERENCES projetos(id),
  criador_id UUID REFERENCES auth.users(id),
  descricao TEXT
);

ALTER TABLE tarefas ENABLE ROW LEVEL SECURITY;
```

---

**Policy INSERT:**
```sql
CREATE POLICY "Members insert tasks in their projects"
ON tarefas
FOR INSERT
WITH CHECK (
  projeto_id IN (
    SELECT projeto_id
    FROM membros_projeto
    WHERE user_id = auth.uid()
  )
);
```

**Tradu√ß√£o:** "Pode criar tarefa se projeto_id t√° na lista de projetos onde √© membro"

---

**Policy UPDATE:**
```sql
CREATE POLICY "Users update own tasks"
ON tarefas
FOR UPDATE
USING (criador_id = auth.uid())
WITH CHECK (criador_id = auth.uid());
```

**Tradu√ß√£o:** "S√≥ pode editar tarefas que criou"

---

**Policy DELETE:**
```sql
CREATE POLICY "Users delete own tasks"
ON tarefas
FOR DELETE
USING (criador_id = auth.uid());
```

**Tradu√ß√£o:** "S√≥ pode deletar tarefas que criou"

---

**Policy SELECT:**
```sql
CREATE POLICY "Members see project tasks"
ON tarefas
FOR SELECT
USING (
  projeto_id IN (
    SELECT projeto_id
    FROM membros_projeto
    WHERE user_id = auth.uid()
  )
);
```

**Tradu√ß√£o:** "V√™ tarefas dos projetos onde √© membro"

---

**Teste:**

Dados:
```
Projetos:
| id | nome           |
|----|----------------|
| 1  | Projeto Alpha  |

Membros:
| projeto_id | user_id |
|------------|---------|
| 1          | abc     |

Tarefas:
| id | projeto_id | criador_id | descricao |
|----|------------|------------|-----------|
| 1  | 1          | abc        | Tarefa 1  |
```

Jo√£o (abc) tenta:
```sql
INSERT INTO tarefas (projeto_id, criador_id, descricao)
VALUES (1, 'abc', 'Nova tarefa');
```
‚úÖ **FUNCIONA** (√© membro do projeto 1)

---

Jo√£o tenta:
```sql
INSERT INTO tarefas (projeto_id, criador_id, descricao)
VALUES (2, 'abc', 'Outra tarefa');
```
‚ùå **BLOQUEADO** (n√£o √© membro do projeto 2)

---

## üåü EXPANS√ÉO FILOS√ìFICA (Camada 5)

Sabe por que te mostro isso?

Porque quando eu comecei, INSERT/UPDATE/DELETE pareciam MUITO complicados.

Tipo:
- "Por que WITH CHECK?"
- "Por que USING + WITH CHECK no UPDATE?"
- "Qual a diferen√ßa?"

---

**Bem, a l√≥gica √© simples:**

**SELECT:** S√≥ l√™. N√£o muda nada. S√≥ precisa de USING (filtrar linhas).

**INSERT:** Cria dados novos. Precisa validar se dados s√£o v√°lidos. Usa WITH CHECK.

**UPDATE:** Edita dados existentes. Precisa:
1. Filtrar quais linhas pode editar (USING)
2. Validar novos valores (WITH CHECK)

**DELETE:** Deleta dados. S√≥ precisa filtrar quais pode deletar (USING).

---

Quando voc√™ entende INSERT/UPDATE/DELETE:

**Voc√™ entende 90% de RLS.**

O resto √© s√≥ combinar condi√ß√µes.

---

**Confessa que voc√™ tinha medo de RLS?**

Pois √©.

Era s√≥ falta de informa√ß√£o.

RLS √© SUPER l√≥gico quando algu√©m explica certo.

---

## ‚úÖ RECAPITULA√á√ÉO (Valida√ß√£o do Aprendizado)

Antes de ir pra pr√≥xima aula, me responde mentalmente:

**1. Qual a diferen√ßa entre USING e WITH CHECK?**
<details>
<summary>Resposta</summary>
USING = filtra linhas EXISTENTES. WITH CHECK = valida dados NOVOS.
</details>

**2. Por que UPDATE precisa de USING + WITH CHECK?**
<details>
<summary>Resposta</summary>
USING = quais linhas pode editar. WITH CHECK = que valores pode colocar.
</details>

**3. O que acontece se tentar INSERT com user_id de outro?**
<details>
<summary>Resposta</summary>
WITH CHECK falha. Erro: "new row violates row-level security policy".
</details>

**4. Por que DELETE n√£o precisa de WITH CHECK?**
<details>
<summary>Resposta</summary>
Porque DELETE n√£o cria dados novos. S√≥ remove. S√≥ precisa filtrar quais pode remover (USING).
</details>

**5. Como criar policy pra admin fazer tudo?**
<details>
<summary>Resposta</summary>
USING (...condi√ß√£o do user... OR is_admin = TRUE) WITH CHECK (TRUE).
</details>

---

Tudo claro?

Porque na pr√≥xima aula, vamos falar de MULTI-TENANT.

Como isolar dados de m√∫ltiplos clientes em um √∫nico banco.

---

## üéØ EXERC√çCIO PR√ÅTICO

**Seu desafio:**

Crie uma tabela `comentarios` com RLS completo:

```sql
-- Tabela
CREATE TABLE comentarios (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id),
  post_id BIGINT,
  texto TEXT
);

-- Habilitar RLS
ALTER TABLE comentarios ENABLE ROW LEVEL SECURITY;
```

---

**Crie 4 policies:**

1. **SELECT:** Qualquer pessoa v√™ todos os coment√°rios
```sql
CREATE POLICY "Public read comments"
ON comentarios
FOR SELECT
USING (TRUE);
```

2. **INSERT:** Usu√°rio s√≥ pode criar coment√°rio com seu pr√≥prio user_id
```sql
CREATE POLICY "Users insert own comments"
ON comentarios
FOR INSERT
WITH CHECK (user_id = auth.uid());
```

3. **UPDATE:** Usu√°rio s√≥ pode editar seus pr√≥prios coment√°rios
```sql
CREATE POLICY "Users update own comments"
ON comentarios
FOR UPDATE
USING (user_id = auth.uid())
WITH CHECK (user_id = auth.uid());
```

4. **DELETE:** Usu√°rio s√≥ pode deletar seus pr√≥prios coment√°rios
```sql
CREATE POLICY "Users delete own comments"
ON comentarios
FOR DELETE
USING (user_id = auth.uid());
```

---

**Teste:**

Insira coment√°rios:
```sql
INSERT INTO comentarios (user_id, post_id, texto)
VALUES
  ('abc', 1, '√ìtimo post!'),
  ('def', 1, 'Concordo!');
```

Fa√ßa login como `abc` e tente:
```sql
-- Ver todos (deve funcionar)
SELECT * FROM comentarios;

-- Editar pr√≥prio (deve funcionar)
UPDATE comentarios SET texto = 'Mudei de ideia' WHERE id = 1;

-- Editar de outro (deve bloquear silenciosamente)
UPDATE comentarios SET texto = 'Hackear' WHERE id = 2;

-- Deletar de outro (deve bloquear silenciosamente)
DELETE FROM comentarios WHERE id = 2;
```

---

**Resposta esperada:**

```
SELECT: Retorna todos os coment√°rios (policy p√∫blica)

UPDATE id=1: Funciona (√© dele)
UPDATE id=2: Nada acontece (USING bloqueou)

DELETE id=2: Nada acontece (USING bloqueou)
```

---

**Checklist Antes de Continuar:**
- [ ] Criei INSERT policy com WITH CHECK
- [ ] Criei UPDATE policy com USING + WITH CHECK
- [ ] Criei DELETE policy com USING
- [ ] Testei bloqueios com diferentes usu√°rios

Se marcou os 4, vamos pra pr√≥xima! üöÄ

---

## üöÄ PR√ìXIMO PASSO

Na pr√≥xima aula (07.4), vamos:
- ‚úÖ Entender multi-tenant (m√∫ltiplos clientes)
- ‚úÖ Isolar dados por tenant_id
- ‚úÖ Armazenar tenant no JWT
- ‚úÖ Performance tuning (indexes)

Multi-tenant √© a forma PROFISSIONAL de rodar SaaS.

Voc√™ vai ver como √© simples.

Bora? üî•

---

**Metadados da Aula:**
- Criada por: Jos√© Amorim (Professor Socr√°tico)
- Framework: Espiral Expansiva + Anti-Impostor Design
- Dura√ß√£o estimada: 18 minutos
- Alignment Target: 95%+ (Objetivo ‚Üí Conte√∫do ‚Üí Exerc√≠cio)
- Fidelity Target: 93%+ (Voice Jos√© Amorim)
- Completeness: 100% (7 camadas + exerc√≠cio + checklist)
