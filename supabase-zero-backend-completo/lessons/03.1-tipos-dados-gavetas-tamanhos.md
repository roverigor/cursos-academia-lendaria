# 03.1 - Tipos de Dados: Gavetas de Tamanhos Diferentes

**M√≥dulo:** 3 - Criando Tabelas de Verdade
**Dura√ß√£o:** 12 minutos
**Objetivo:** Entender que diferentes dados precisam de diferentes "gavetas"
**Bloom Level:** Understand
**Sources:** Supabase Docs (Data Types), PostgreSQL Official

---

## üéØ O Que Voc√™ Vai Aprender

Ao final desta aula, voc√™ vai entender:
- ‚úÖ Banco de dados tem "gavetas" de tamanhos diferentes
- ‚úÖ Cada tipo de dado tem seu lugar correto
- ‚úÖ Escolher tipo errado = problema depois
- ‚úÖ Tipos principais que voc√™ REALMENTE usa

---

## üî• GANCHO EMOCIONAL (Camada 1)

Imagina que voc√™ t√° organizando uma casa.

Voc√™ n√£o guarda:
- ‚ùå Um l√°pis numa caixa de 10 metros
- ‚ùå Uma geladeira numa caixa de sapato
- ‚ùå Um arquivo gigante numa USB de 1GB

Cada coisa tem seu tamanho de caixa IDEAL.

---

**Banco de dados √© igual.**

Se voc√™ quer guardar:
- Um n√∫mero de telefone (10 d√≠gitos)
- Um CPF (11 d√≠gitos)
- A popula√ß√£o da China (1.4 bilh√µes)
- A idade de algu√©m (0-150)

Voc√™ usa tipos de dados DIFERENTES.

---

Por qu√™?

Porque usar o tipo errado = banco fica lento, ocupa espa√ßo errado, e depois quebra.

---

## üè† MET√ÅFORA VISUAL (Camada 2)

Pensa numa **loja de roupas**.

Ela tem gavetas de tamanhos diferentes:

```
Gaveta 1 (Pequena - Meias)
‚îú‚îÄ Cabe 100 pares
‚îú‚îÄ Tamanho: 20cm x 30cm
‚îî‚îÄ Compacta, eficiente

Gaveta 2 (M√©dia - Camisetas)
‚îú‚îÄ Cabe 20 camisetas
‚îú‚îÄ Tamanho: 50cm x 50cm
‚îî‚îÄ Espa√ßo suficiente

Gaveta 3 (Grande - Casacos)
‚îú‚îÄ Cabe 5 casacos
‚îú‚îÄ Tamanho: 80cm x 100cm
‚îî‚îÄ Precisa de muito espa√ßo
```

Se voc√™:
- ‚úÖ Coloca meias na gaveta pequena ‚Üí Perfeito
- ‚ùå Coloca casaco na gaveta de meias ‚Üí N√£o cabe
- ‚ùå Coloca meia na gaveta de casaco ‚Üí Desperdi√ßa espa√ßo

---

**Banco de dados √© igual.**

```
Tipo TINY (Gaveta Pequena)
‚îú‚îÄ N√∫meros 0-255
‚îú‚îÄ Usa 1 byte de mem√≥ria
‚îî‚îÄ Perfeito pra: idade, quantidade, status

Tipo INTEGER (Gaveta M√©dia)
‚îú‚îÄ N√∫meros at√© 2 bilh√µes
‚îú‚îÄ Usa 4 bytes
‚îî‚îÄ Perfeito pra: ID, quantidade de usu√°rios

Tipo BIGINT (Gaveta Grande)
‚îú‚îÄ N√∫meros gigantes (at√© 9 quintilh√µes)
‚îú‚îÄ Usa 8 bytes
‚îî‚îÄ Perfeito pra: ID distribu√≠do, timestamp
```

Se voc√™:
- ‚úÖ Usa TINYINT pra idade ‚Üí Eficiente
- ‚ùå Usa BIGINT pra idade ‚Üí Desperdi√ßa espa√ßo
- ‚úÖ Usa INTEGER pra ID ‚Üí Funciona
- ‚ùå Usa TINYINT pra ID com 1 milh√£o de registros ‚Üí Quebra (m√°ximo 255)

---

## üí° FUNDAMENTO CONCEITUAL (Camada 3)

Agora deixa eu te mostrar os tipos que voc√™ REALMENTE usa...

(N√£o s√£o 50. S√£o tipo 5-6.)

### Os Tipos que Voc√™ Precisa Saber

**1. INTEGER / BIGINT (N√∫meros Inteiros)**

```
Type: INTEGER (ou INT)
Size: 4 bytes
Range: -2.147.483.648 at√© 2.147.483.647
Best for: ID's pequenos, contador, quantidades

Type: BIGINT (ou INT8)
Size: 8 bytes
Range: -9 quintilh√µes at√© 9 quintilh√µes
Best for: IDs muito grandes, distributed systems
```

**Quando usar cada um?**
- INTEGER: 99% das vezes (ID de 1 a 1 bilh√£o)
- BIGINT: Se voc√™ tem MAIS de 1 bilh√£o de registros (Amazon, Google, Meta)

**Exemplo Pr√°tico:**
```sql
-- Tabela de usu√°rios (ID 1 a 100.000.000)
CREATE TABLE usuarios (
  id INTEGER PRIMARY KEY,  ‚Üê Suficiente
  nome TEXT
);

-- Tabela de eventos distribu√≠da globalmente
CREATE TABLE eventos (
  id BIGINT PRIMARY KEY,  ‚Üê Necess√°rio
  descricao TEXT
);
```

---

**2. TEXT (Texto)**

```
Type: TEXT (ou VARCHAR)
Size: Sem limite
Best for: Qualquer texto (nome, email, descri√ß√£o, blog post)
```

**Importante:** N√£o precisa de "tamanho m√°ximo". PostgreSQL otimiza sozinho.

```sql
-- ‚ùå ERRADO (n√£o precisa)
CREATE TABLE usuarios (
  nome VARCHAR(100)  ‚Üê Limite desnecess√°rio
);

-- ‚úÖ CERTO (fica melhor)
CREATE TABLE usuarios (
  nome TEXT  ‚Üê PostgreSQL otimiza sozinho
);
```

---

**3. BOOLEAN (Verdadeiro / Falso)**

```
Type: BOOLEAN
Size: 1 byte
Values: TRUE ou FALSE
Best for: Flags, status, sim/n√£o
```

**Exemplo:**
```sql
CREATE TABLE usuarios (
  id INTEGER PRIMARY KEY,
  nome TEXT,
  email_verificado BOOLEAN DEFAULT FALSE,  ‚Üê Padr√£o √© FALSE
  premium BOOLEAN DEFAULT FALSE
);

-- Inserindo
INSERT INTO usuarios (nome, email_verificado)
VALUES ('Jo√£o', TRUE);
```

---

**4. DATE / TIMESTAMP (Data e Hora)**

```
Type: DATE
Format: YYYY-MM-DD
Size: 4 bytes
Best for: Apenas datas (anivers√°rio, data de reuni√£o)

Type: TIMESTAMP (ou TIMESTAMP WITH TIME ZONE)
Format: YYYY-MM-DD HH:MM:SS
Size: 8 bytes
Best for: Quando/criar, quando/atualizar, registros de auditoria
```

**Exemplo:**
```sql
CREATE TABLE tarefas (
  id INTEGER PRIMARY KEY,
  descricao TEXT,
  data_vencimento DATE,  ‚Üê S√≥ a data (01/01/2025)
  criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  ‚Üê Com hor√°rio
  atualizado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Valores
INSERT INTO tarefas (descricao)
VALUES ('Comprar leite');
-- criado_em preenchido automaticamente com hor√°rio AGORA
```

---

**5. JSON / JSONB (Dados Complexos)**

```
Type: JSONB (use sempre este, n√£o JSON)
Size: Varia
Best for: Dados semiflex√≠veis (configura√ß√µes, atributos dinamicamente)
```

**Exemplo (Sistema de Produtos):**
```sql
CREATE TABLE produtos (
  id INTEGER PRIMARY KEY,
  nome TEXT,
  preco NUMERIC,
  atributos JSONB  ‚Üê Dados flexible
);

-- Produto com atributos diferentes
INSERT INTO produtos (nome, preco, atributos)
VALUES
  ('Camiseta', 50, '{"cor": "azul", "tamanho": "M"}'),
  ('Livro', 80, '{"autor": "Jos√© Saramago", "p√°ginas": 300}');
```

**Importante:** JSONB (B = Binary) √© mais r√°pido que JSON. Use sempre JSONB.

---

**6. NUMERIC / DECIMAL (N√∫meros com Decimal)**

```
Type: NUMERIC (ou DECIMAL)
Size: Varia conforme precis√£o
Best for: Dinheiro, medi√ß√µes que precisam de exatid√£o
```

**Exemplo:**
```sql
CREATE TABLE vendas (
  id INTEGER PRIMARY KEY,
  descricao TEXT,
  valor NUMERIC(10, 2)  ‚Üê 10 d√≠gitos, 2 casas decimais
                        ‚Üê M√°ximo: 99999999.99
);

-- Valores
INSERT INTO vendas (descricao, valor) VALUES ('Produto A', 19.99);
```

**Importante:** Para dinheiro, NUNCA use FLOAT/DOUBLE (perdem precis√£o).

---

### Os Tipos Que Voc√™ N√ÉO Precisa Saber (Ainda)

- ‚ùå SMALLINT (INTEGER √© melhor)
- ‚ùå BYTEA (imagens/videos ‚Üí upload em Storage)
- ‚ùå INTERVAL (date math ‚Üí PostgreSQL calcula)
- ‚ùå ARRAY (use JSON em vez disso)

Quando crescer, voc√™ aprende. Por enquanto, seis tipos acima s√£o 99% do que voc√™ precisa.

---

## ‚ö° APLICA√á√ÉO PR√ÅTICA (Camada 4)

Agora voc√™ va **ver na pr√°tica** como escolher tipos...

### Scenario: App de E-commerce

Voc√™ vai criar uma tabela de `produtos`. Qual tipo para cada coluna?

```
Coluna: id
Pergunta: "Quantos produtos vou ter?"
Resposta: "Uns 100 mil no m√°ximo"
Tipo: INTEGER ‚úÖ (m√°ximo 2 bilh√µes)

Coluna: nome
Pergunta: "√â texto?"
Resposta: "Sim, nome do produto"
Tipo: TEXT ‚úÖ

Coluna: preco
Pergunta: "√â dinheiro?"
Resposta: "Sim, R$ com centavos"
Tipo: NUMERIC(10, 2) ‚úÖ

Coluna: em_estoque
Pergunta: "√â sim/n√£o?"
Resposta: "Sim, tem em estoque ou n√£o"
Tipo: BOOLEAN ‚úÖ

Coluna: criado_em
Pergunta: "Quando foi criado?"
Resposta: "Data E hora"
Tipo: TIMESTAMP ‚úÖ

Coluna: atributos (cores dispon√≠veis, tamanhos, etc)
Pergunta: "√â estruturado?"
Resposta: "N√£o, varia por produto"
Tipo: JSONB ‚úÖ
```

**Tabela Final:**
```sql
CREATE TABLE produtos (
  id INTEGER PRIMARY KEY,
  nome TEXT,
  preco NUMERIC(10, 2),
  em_estoque BOOLEAN DEFAULT TRUE,
  criado_em TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  atributos JSONB
);
```

Simples assim.

---

## üåü EXPANS√ÉO FILOS√ìFICA (Camada 5)

Sabe a diferen√ßa entre um dev junior e um dev senior?

Dev junior pensa: "Vou usar TEXT pra tudo"
Dev senior pensa: "Qual √© o tipo CORRETO?"

Por qu√™? Porque tipo certo = performance = dinheiro economizado.

Imagine um banco com 1 MILH√ÉO de usu√°rios:

```
‚ùå Se usar BIGINT pra age (quando INTEGER bastar√≠a):
   1.000.000 √ó 8 bytes = 8 MB desperdi√ßados

‚úÖ Se usar INTEGER:
   1.000.000 √ó 4 bytes = 4 MB

Diferen√ßa: 4 MB pode n√£o parecer muito...
Mas em 10 tabelas com 10 milh√µes de registros cada = 400 MB de lixo.
```

Tipo certo = custo menor no banco = voc√™ paga menos.

---

E tem outra coisa: **valida√ß√£o de neg√≥cio**.

Se voc√™ usa NUMERIC(10,2) pra pre√ßo:
- O banco garante que NUNCA tem mais de 2 casas decimais
- N√£o precisa validar no c√≥digo
- Integridade garantida

Se voc√™ usa TEXT:
- Algu√©m pode guardar "duzentos reais" em vez de 200.00
- Seu c√≥digo quebra depois
- Dor de cabe√ßa.

---

**Conclus√£o:**

Tipo certo desde o come√ßo = menos problema depois.

Voc√™ j√° t√° fazendo certo pedindo essa pesquisa web! üéØ

---

## ‚úÖ RECAPITULA√á√ÉO (Valida√ß√£o do Aprendizado)

Antes de ir pra pr√≥xima aula, me responde:

**1. Por que usar tipos diferentes de dados?**
Resposta: Cada tipo otimiza mem√≥ria e performance.

**2. Qual tipo voc√™ usa para idade?**
Resposta: INTEGER ou TINYINT (0-255).

**3. Qual tipo para dinheiro?**
Resposta: NUMERIC(10,2) - NUNCA FLOAT.

**4. TEXT pode ter tamanho m√°ximo?**
Resposta: N√£o, PostgreSQL otimiza sozinho.

**5. Qual tipo para "sim/n√£o"?**
Resposta: BOOLEAN.

---

## üéØ PR√ìXIMO PASSO

Na pr√≥xima aula (03.2), vamos:
- ‚úÖ Entender por que UUID existe
- ‚úÖ Quando usar UUID vs INTEGER
- ‚úÖ Como gerar UUID no Supabase

Spoiler: UUID √© para quando seu app fica MUITO grande.

Bora? üöÄ

---

*Aula criada por Jos√© Amorim (Professor Socr√°tico)*
*Framework: Espiral Expansiva + Anti-Impostor Design*
*Dura√ß√£o estimada: 12 minutos*
*Fonte: Supabase Docs Data Types | PostgreSQL Official Docs*
