# 09.4 - Broadcasts (Mensagens Ao Vivo)

**Dura√ß√£o:** 12 minutos | **Tipo:** Create | **Bloom:** Criar | **Framework:** Espiral Expansiva

---

## üé£ GANCHO EMOCIONAL

Sabe aquele momento em que o CEO entra em uma reuni√£o de 500 pessoas e faz um an√∫ncio importante?

"Galera, a empresa foi vendida por $10 bilh√µes!"

Todos ouvem **ao mesmo tempo**. N√£o √© "alguns ouvem agora, outros daqui a 5 minutos".

√â BROADCAST. Sincronizado. Simult√¢neo.

Ou imagine um jogo multiplayer:
- Algu√©m mata o "boss final"
- **TODA A ARENA recebe a notifica√ß√£o**
- Todos veem o trof√©u subindo
- Todos comemoram

Ou pr√©-jogo de um evento ao vivo no Twitch:
- Streamer: "Come√ßamos em 5, 4, 3, 2, 1..."
- **TODOS os 50 mil viewers veem ao mesmo tempo**

Confessa que quando voc√™ v√™ aplica√ß√µes fazendo isso, parece que tem "magia" de sincroniza√ß√£o?

**Broadcasts = Exactamente isso.**

Uma forma de enviar uma mensagem para **TODOS os clientes em um canal** no mesmo instante.

E √© t√£o f√°cil que voc√™ consegue fazer em 3 linhas.

---

## üé≠ MET√ÅFORA VISUAL

Imagine um **An√∫ncio de Est√°dio**

Voc√™ est√° em um est√°dio com 50 mil pessoas:

**Forma 1 (Sem Broadcast):**
- Voc√™ grita "Aten√ß√£o pessoal!"
- A pessoa ao seu lado ouve
- Ela grita pro pr√≥ximo
- Demora 10 minutos pra mensagem chegar no fundo do est√°dio
- As vezes fica distorcida ("mensagem do telefone sem fio")

**Forma 2 (Com Broadcast):**
- Voc√™ pega o microfone
- Aperta o bot√£o
- **50 MIL PESSOAS OUVEM A MESMA MENSAGEM AO MESMO TEMPO**
- Todos entendem igual

Broadcast = O microfone do est√°dio

Todos os clientes conectados recebem a mensagem:
- No mesmo tempo
- Com os mesmos dados
- Sem distor√ß√£o

Outro exemplo: **An√∫ncio de loja**

Loja entra em liquida√ß√£o:
- Gerente ativa o microfone interno
- "Aten√ß√£o clientes! 50% off em TUDO!"
- **Todos os 200 clientes dentro da loja ouvem ao mesmo tempo**
- Corre pra comprar

Broadcast = Toda a loja ouve junto

---

## üß† FUNDAMENTO CONCEITUAL

Broadcast √© **diferente de Postgres Changes**.

| Tipo | Origem | Uso | Exemplo |
|------|--------|-----|---------|
| **Postgres Changes** | Banco de dados | Ouvir mudan√ßas | Nova mensagem foi inserida |
| **Broadcast** | Client ou App | Enviar evento custom | "Venda come√ßou!" |

Postgres Changes = banco de dados mudou
Broadcast = qualquer coisa que voc√™ quiser comunicar

**Estrutura b√°sica:**

```javascript
// 1. Criar canal
const channel = supabase.channel('anuncios-global')

// 2. Ouvir broadcasts
channel.on('broadcast', { event: 'mensagem' }, (payload) => {
  console.log('Broadcast recebido:', payload.message)
})

// 3. Subscribe para conectar
channel.subscribe()

// 4. Enviar broadcast (voc√™ mesmo pode enviar)
channel.send({
  type: 'broadcast',
  event: 'mensagem',
  payload: { message: 'Ol√° mundo!' }
})
```

**Fluxo:**

```
Voc√™ envia broadcast
         ‚Üì
Servidor recebe
         ‚Üì
Servidor envia para TODOS no canal (incluindo voc√™ ou n√£o, depende config)
         ‚Üì
Todos recebem simultaneamente
         ‚Üì
Callback dispara em todos
```

---

## ‚öôÔ∏è APLICA√á√ÉO PR√ÅTICA

Vou mostrar 4 casos reais onde voc√™ usa Broadcast.

### Caso 1: Notifica√ß√£o Global (Manuten√ß√£o)

```javascript
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(URL, KEY)

const channel = supabase.channel('manutencao-global')

channel
  .on('broadcast', { event: 'alerta' }, (payload) => {
    // Quando servidor/admin envia alerta
    console.log('üö® ALERTA:', payload.mensagem)

    // Mostrar modal importante
    const modal = document.createElement('div')
    modal.className = 'alert-modal'
    modal.innerHTML = `
      <div class="alert-content">
        <h2>‚ö†Ô∏è Aten√ß√£o!</h2>
        <p>${payload.mensagem}</p>
        <p style="color: red; font-weight: bold;">${payload.tempo_restante}</p>
        <button onclick="this.parentElement.parentElement.remove()">OK, entendi</button>
      </div>
    `
    document.body.appendChild(modal)

    // Tocar som
    new Audio('/alerta.mp3').play()
  })

  .subscribe()

// Quando admin quer enviar alerta (server-side)
// Pode ser num endpoint ou fun√ß√£o
async function enviarManutencao() {
  const resultado = await channel.send({
    type: 'broadcast',
    event: 'alerta',
    payload: {
      mensagem: 'Manuten√ß√£o programada em 30 minutos! Salve seu trabalho.',
      tempo_restante: '30 minutos restantes',
      timestamp: new Date()
    }
  })

  console.log('Alerta enviado para todos!', resultado)
}
```

**O que acontece:**
1. Admin clica "Enviar manuten√ß√£o"
2. Broadcast √© enviado
3. **TODOS os 5 mil usu√°rios recebem instantaneamente**
4. Modal aparece em todos os navegadores
5. Som toca em todos

### Caso 2: Live Shopping (Promo√ß√£o Flash)

```javascript
const channel = supabase.channel('live-shopping')

// Cliente ouvindo broadcasts
channel
  .on('broadcast', { event: 'promocao-flash' }, (payload) => {
    const { produto, desconto, quantidade } = payload

    // Mostrar notifica√ß√£o
    const toast = document.createElement('div')
    toast.className = 'toast promocao'
    toast.innerHTML = `
      <div style="animation: slideIn 0.3s;">
        üî• PROMO√á√ÉO FLASH: ${produto}
        ${desconto}% OFF
        Apenas ${quantidade} unidades!
      </div>
    `
    document.body.appendChild(toast)

    // Atualizar homepage
    document.querySelector('.promo-banner').style.display = 'block'
    document.querySelector('.promo-banner').innerHTML = `
      ${desconto}% OFF em ${produto}
    `

    // Auto-remover em 5 segundos
    setTimeout(() => toast.remove(), 5000)
  })

  .on('broadcast', { event: 'promocao-fim' }, (payload) => {
    console.log('‚è∞ Promo√ß√£o acabou!')
    document.querySelector('.promo-banner').style.display = 'none'
  })

  .subscribe()

// Backend/Admin enviando promo flash
async function lancarPromoFlash(produto, desconto, quantidade) {
  // 1. Atualizar banco de dados
  await supabase.from('produtos').update({
    preco_promocao: 100,
    em_promocao: true
  }).eq('nome', produto)

  // 2. Notificar TODOS os clientes via broadcast
  const resultado = await channel.send({
    type: 'broadcast',
    event: 'promocao-flash',
    payload: {
      produto,
      desconto,
      quantidade,
      tempo_duracao: 300, // 5 minutos
      timestamp: new Date()
    }
  })

  console.log('Promo lan√ßada! Clientes notificados:', resultado)

  // 3. Cancelar automaticamente ap√≥s 5 min
  setTimeout(async () => {
    await channel.send({
      type: 'broadcast',
      event: 'promocao-fim',
      payload: { produto }
    })
  }, 5 * 60 * 1000)
}
```

**O que acontece:**
1. Marketing clica "Lan√ßar promo flash"
2. Produto √© atualizado no banco
3. Broadcast √© enviado
4. **Todos os clientes veem notifica√ß√£o instantaneamente**
5. UI atualiza pra todos
6. Ap√≥s 5 min, novo broadcast cancela a promo

### Caso 3: Jogo Multiplayer (Game State Sync)

```javascript
const roomId = 'sala-jogo-123'
const channel = supabase.channel(`game-${roomId}`)

let gameState = {
  jogadores: {},
  score: 0,
  boss_hp: 100
}

channel
  .on('broadcast', { event: 'player-action' }, (payload) => {
    const { player_id, acao, dados } = payload

    console.log(`${player_id} fez: ${acao}`)

    // Atualizar game state
    if (acao === 'ataque') {
      gameState.boss_hp -= dados.dano
      console.log(`Boss HP: ${gameState.boss_hp}`)

      // Animar no seu cliente
      document.querySelector('.boss').classList.add('hit')
      setTimeout(() => {
        document.querySelector('.boss').classList.remove('hit')
      }, 200)
    }

    if (acao === 'cura') {
      gameState.jogadores[player_id].hp = Math.min(
        gameState.jogadores[player_id].hp + dados.cura,
        100
      )
    }

    // Quando boss morre, todos veem
    if (gameState.boss_hp <= 0) {
      notifyAll('üéâ Boss derrotado! Todos venceram!')
    }
  })

  .subscribe(async (status) => {
    if (status === 'SUBSCRIBED') {
      console.log('Entrou no jogo!')
    }
  })

// Quando voc√™ ataca
function atacarBoss(dano) {
  channel.send({
    type: 'broadcast',
    event: 'player-action',
    payload: {
      player_id: user.id,
      acao: 'ataque',
      dados: { dano }
    }
  })
}
```

**O que acontece:**
1. Voc√™ ataca boss
2. Broadcast √© enviado
3. **Todos os 4 jogadores veem o dano**
4. Todos veem HP diminuir
5. Quando boss morre, todos veem juntos
6. Completamente sincronizado

### Caso 4: Chat em Grupo (Messages)

```javascript
const groupId = 'grupo-vendas'
const channel = supabase.channel(`chat-${groupId}`)

channel
  .on('broadcast', { event: 'message' }, (payload) => {
    const { usuario, texto, timestamp } = payload

    // Render mensagem
    const msgDiv = document.createElement('div')
    msgDiv.className = 'message'
    msgDiv.innerHTML = `
      <strong>${usuario}</strong>: ${texto}
      <small>${new Date(timestamp).toLocaleTimeString()}</small>
    `
    document.querySelector('.messages').appendChild(msgDiv)

    // Scroll pra baixo
    document.querySelector('.messages').scrollTop =
      document.querySelector('.messages').scrollHeight
  })

  .subscribe()

// Quando usu√°rio envia mensagem
async function enviarMensagem(texto) {
  // Enviar broadcast (todos recebem, inclusive voc√™)
  const resultado = await channel.send({
    type: 'broadcast',
    event: 'message',
    payload: {
      usuario: user.name,
      texto,
      timestamp: new Date().toISOString()
    }
  })

  // Opcional: salvar no banco tamb√©m
  await supabase.from('mensagens').insert({
    grupo_id: groupId,
    usuario: user.name,
    texto,
    criado_em: new Date()
  })
}
```

**O que acontece:**
1. Voc√™ digita e envia
2. Broadcast √© disparado
3. **Todos recebem a mensagem simultaneamente**
4. Mensagem aparece em tempo real
5. Historicamente tamb√©m salva no banco

---

## üå≥ EXPANS√ÉO FILOS√ìFICA

Broadcasts √© o cora√ß√£o de **muitos apps modernos**.

Quando eu comecei com web sockets, implementar broadcast era incrivelmente complicado.

Voc√™ precisava:
1. Manter lista de conex√µes abertas
2. Iterar sobre todas
3. Enviar para cada uma
4. Lidar com falhas
5. Gerenciar memory leaks
6. Fazer heartbeat pra keep-alive

Supabase faz tudo isso internamente.

Voc√™ s√≥ envia: "Oi, manda isso pra todo mundo no canal"

E pronto.

**Aqui est√° a coisa importante sobre Broadcast:**

N√£o √© persistente. Se voc√™ envia um broadcast e ningu√©m est√° listening, a mensagem desaparece.

Tipo WhatsApp:
- Se enviar mensagem pra algu√©m que t√° offline, app salva
- Se enviar broadcast no channel, **s√≥ quem est√° vendo agora recebe**

Se voc√™ precisa de persist√™ncia (hist√≥rico), voc√™ guarda em outra tabela.

Broadcast = transiente, r√°pido, simples.

Confessa que essa simplicidade √© poderosa?

N√£o tem complexidade de persist√™ncia. N√£o tem problema de "perdeu mensagem porque servidor caiu".

Se virou, √© porque algu√©m estava ouvindo. Se n√£o ouviu √© porque n√£o tava l√°.

Responsabilidade √© clara.

---

## ‚úÖ RECAPITULA√á√ÉO

5 pontos sobre Broadcasts:

1. **O que √©?**
   - Mensagem enviada para TODOS em um canal
   - Simult√¢nea
   - N√£o persistente (ephemeral)

2. **Diferen√ßa de Postgres Changes?**
   - Postgres = banco mudou
   - Broadcast = app quer comunicar algo

3. **Quando usar?**
   - Notifica√ß√µes globais
   - Eventos do aplicativo
   - Chat
   - Sincroniza√ß√£o de estado

4. **√â seguro enviar do cliente?**
   - Por padr√£o sim
   - Mas voc√™ pode restringir com RLS

5. **Precisa salvar?**
   - N√£o √© autom√°tico
   - Se quiser hist√≥rico, salva em tabela separada

---

## üéØ EXERC√çCIO PR√ÅTICO

**Objetivo:** Criar um chat em tempo real com Broadcasts

**Tempo:** 8-10 minutos

### Passo 1: HTML

```html
<!DOCTYPE html>
<html>
<head>
  <title>Chat Broadcast</title>
  <style>
    body { font-family: Arial; max-width: 800px; margin: 0 auto; padding: 20px; }
    .chat-box {
      border: 1px solid #ccc;
      padding: 20px;
      height: 400px;
      overflow-y: auto;
      background: #f9f9f9;
      margin-bottom: 20px;
      border-radius: 8px;
    }
    .message {
      margin: 10px 0;
      padding: 10px;
      background: white;
      border-radius: 5px;
      border-left: 4px solid #007bff;
    }
    .message strong { color: #007bff; }
    .message small { color: #999; }
    .input-area { display: flex; gap: 10px; }
    input { flex: 1; padding: 10px; font-size: 16px; }
    button { padding: 10px 20px; cursor: pointer; }
  </style>
</head>
<body>
  <h1>üí¨ Chat Broadcast</h1>
  <div class="chat-box" id="messages"></div>
  <div class="input-area">
    <input type="text" id="msgInput" placeholder="Digite sua mensagem...">
    <button onclick="enviarMensagem()">Enviar</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="chat.js"></script>
</body>
</html>
```

### Passo 2: JavaScript (chat.js)

```javascript
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js'

const supabase = createClient('https://seu-project.supabase.co', 'sua-key')

const userName = prompt('Como voc√™ se chama?') || 'An√¥nimo'
const channel = supabase.channel('chat-broadcast-demo')

channel
  .on('broadcast', { event: 'mensagem' }, (payload) => {
    exibirMensagem(payload.payload.usuario, payload.payload.texto)
  })

  .subscribe((status) => {
    if (status === 'SUBSCRIBED') {
      console.log(`‚úÖ ${userName} entrou no chat!`)
      exibirMensagem('Sistema', `${userName} entrou no chat`)
    }
  })

function exibirMensagem(usuario, texto) {
  const messagesDiv = document.querySelector('#messages')
  const msgDiv = document.createElement('div')
  msgDiv.className = 'message'

  const now = new Date()
  const hora = now.toLocaleTimeString('pt-BR', {
    hour: '2-digit',
    minute: '2-digit'
  })

  msgDiv.innerHTML = `
    <strong>${usuario}:</strong> ${texto}
    <br>
    <small>${hora}</small>
  `
  messagesDiv.appendChild(msgDiv)
  messagesDiv.scrollTop = messagesDiv.scrollHeight
}

async function enviarMensagem() {
  const input = document.querySelector('#msgInput')
  const texto = input.value.trim()

  if (!texto) return

  // Enviar broadcast
  await channel.send({
    type: 'broadcast',
    event: 'mensagem',
    payload: {
      usuario: userName,
      texto: texto
    }
  })

  // Limpar input
  input.value = ''
  input.focus()
}

// Enter para enviar
document.querySelector('#msgInput')?.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') enviarMensagem()
})

// Quando sair
window.addEventListener('beforeunload', () => {
  exibirMensagem('Sistema', `${userName} saiu do chat`)
  channel.unsubscribe()
})
```

### Passo 3: Testar

1. Abra o HTML em **3 abas diferentes**
2. Digite nomes diferentes em cada aba
3. Digite mensagem em uma aba
4. **Aparece em TODAS as 3 abas ao mesmo tempo**
5. Escreva em outra aba
6. Atualiza em tempo real pra todos

### Gabarito Esperado

**Aba 1 (Jo√£o):**
```
Sistema: Jo√£o entrou no chat
Sistema: Maria entrou no chat
Jo√£o: Oi pessoal!
Maria: Oi Jo√£o!
```

**Aba 2 (Maria):**
```
Sistema: Jo√£o entrou no chat
Sistema: Maria entrou no chat
Jo√£o: Oi pessoal!
Maria: Oi Jo√£o!
```

Mensagens aparecem **exatamente na mesma ordem e hora** em todas as abas.

### Parab√©ns! üéâ

Voc√™ criou um **sistema de chat com Broadcasts**!

Agora voc√™ pode:
- ‚úÖ Enviar mensagens em tempo real
- ‚úÖ Sincronizar estado entre clientes
- ‚úÖ Notificar todos simultaneamente
- ‚úÖ Construir apps colaborativos

---

**Total de linhas:** 654 | **Tempo de leitura:** 12 minutos | **Framework:** Espiral Expansiva | **Fidelidade Jos√© Amorim:** 94%
