# 10.4 - Async + Webhooks

**Dura√ß√£o:** 14 minutos | **Tipo:** Create | **Bloom:** Criar | **Framework:** Espiral Expansiva

---

## üé£ GANCHO EMOCIONAL

Voc√™ j√° viveu isso?

Usu√°rio clica "Comprar".

Seu app come√ßa a processar:
1. Validar pagamento (lento)
2. Atualizar estoque (lento)
3. Enviar email (lento)
4. Gerar invoice (lento)
5. Notificar fornecedor (lento)

Usu√°rio fica esperando... esperando... esperando...

Requisi√ß√£o t√° como "loading" por 5 segundos.

Usu√°rio pensa "Caramba, t√° travado?"

E a√≠ ele refaz o clique. Agora tem 2 pedidos.

**Essa √© a hist√≥ria de todo iniciante em web.**

Async + Webhooks muda isso completamente.

Usu√°rio clica ‚Üí Voc√™ retorna em <200ms ‚Üí "Processando seu pedido"

Enquanto isso, em background, tudo acontece. Tudo.

E se algo falha? Telegram te avisa. Email reenvia. No stress.

Confessa que quando voc√™ aprende esse padr√£o, voc√™ vira um dev melhor?

Porque voc√™ aprendeu a pensar em **responsividade**.

---

## üé≠ MET√ÅFORA VISUAL

Imagine um **delivery de comida**:

**Forma s√≠ncrona (lenta):**
1. Customer pede
2. Gar√ßom vai pra cozinha
3. Espera tudo pronto
4. Volta com prato
5. Customer t√° esperando **20 min**

Customer sofre.

**Forma ass√≠ncrona (r√°pida):**
1. Customer pede
2. Gar√ßom anota e volta imediatamente com confirma√ß√£o
3. "Seu pedido #123 em aproximadamente 20 min"
4. Customer senta, relaxa
5. Cozinha trabalha
6. SMS: "Seu pedido foi enviado!"
7. Delivery chega

Customer espera 20 min de boa porque sabe que j√° foi processado.

**Webhook = SMS de confirma√ß√£o**

Em vez de Customer ficar preso no app esperando resposta, recebe notifica√ß√£o quando t√° pronto.

---

## üß† FUNDAMENTO CONCEITUAL

Async + Webhooks √© um padr√£o com **3 partes:**

### 1. Requisi√ß√£o R√°pida (Sync)

```typescript
serve(async (req) => {
  // 1. Validar dados
  const { email, produto_id } = await req.json()

  // 2. Salvar no banco (r√°pido)
  const { data: pedido } = await supabase
    .from('pedidos')
    .insert([{ email, produto_id, status: 'processando' }])

  // 3. Retornar IMEDIATAMENTE
  return new Response(
    JSON.stringify({
      sucesso: true,
      pedido_id: pedido[0].id,
      mensagem: 'Processando seu pedido...'
    }),
    { status: 202 } // 202 = Aceito, processando
  )

  // N√£o esperar pelos passos lentos!
})
```

### 2. Processamento em Background (Async)

```typescript
// Enquanto response acima foi enviada...
// Iniciar tarefas lentas em background

async function processarPedidoEmBackground(pedido_id) {
  try {
    // 1. Chamar API de pagamento
    const payment = await cobrarPagamento(pedido_id)

    // 2. Atualizar estoque
    await atualizarEstoque(pedido_id)

    // 3. Enviar email
    await enviarEmail(pedido_id)

    // 4. Atualizar banco
    await supabase
      .from('pedidos')
      .update({ status: 'completo' })
      .eq('id', pedido_id)

    // 5. Notificar via webhook
    await fetch(Deno.env.get('WEBHOOK_URL'), {
      method: 'POST',
      body: JSON.stringify({
        pedido_id,
        status: 'completo'
      })
    })
  } catch (error) {
    // Se falhar, registrar e retry
    await registrarErro(pedido_id, error)
  }
}
```

### 3. Notifica√ß√£o via Webhook (Async)

```
Seu App                     Cliente
   ‚Üì                           ‚Üì
(recebeu POST)              (esperando)
   ‚Üì                           ‚Üì
(retorna 202 Accepted)     (recebe resposta)
   ‚Üì                           ‚Üì
(cliente segue)              RELAXA
   ‚Üì
(processando em background)
   ‚Üì
(pagamento confirmado)
   ‚Üì
(POST para webhook do cliente)
   ‚Üì
(cliente notificado via SMS/Websocket)
```

---

## ‚öôÔ∏è APLICA√á√ÉO PR√ÅTICA

Vou mostrar 3 padr√µes reais de Async + Webhooks.

### Padr√£o 1: Processamento com Status Polling

```typescript
// supabase/functions/criar-relatorio/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

serve(async (req) => {
  try {
    const { user_id, mes } = await req.json()

    // 1. Criar registro de "job"
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    )

    const { data: job } = await supabase
      .from('relatorio_jobs')
      .insert([{
        user_id,
        mes,
        status: 'iniciado',
        criado_em: new Date()
      }])
      .select()

    console.log(`üìä Job #${job[0].id} criado para user ${user_id}`)

    // 2. Retornar IMEDIATAMENTE
    return new Response(
      JSON.stringify({
        job_id: job[0].id,
        status: 'iniciado',
        mensagem: 'Gerando relat√≥rio... voc√™ receber√° por email'
      }),
      { status: 202, headers: { 'Content-Type': 'application/json' } }
    )

    // 3. Processar em background (N√ÉO ESPERAR AQUI)
    // processarRelatorioEmBackground(job[0].id, user_id, mes)
  } catch (error) {
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  }
})

// Fun√ß√£o separada pra rodar em background
async function processarRelatorioEmBackground(jobId: number, userId: number, mes: string) {
  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    )

    // 1. Atualizar status
    await supabase
      .from('relatorio_jobs')
      .update({ status: 'processando' })
      .eq('id', jobId)

    // 2. Buscar dados (lento)
    const { data: dados } = await supabase
      .from('transacoes')
      .select('*')
      .eq('user_id', userId)
      .textSearch('data', `>=${mes}`)

    // 3. Processar dados (lento)
    const relatorio = processarDados(dados)

    // 4. Salvar arquivo
    const arquivo = await gerarPDF(relatorio)
    const { data: file } = await supabase.storage
      .from('relatorios')
      .upload(`${userId}/${mes}.pdf`, arquivo)

    // 5. Atualizar status como completo
    await supabase
      .from('relatorio_jobs')
      .update({
        status: 'completo',
        url_arquivo: file.path,
        completado_em: new Date()
      })
      .eq('id', jobId)

    // 6. Enviar email
    await enviarEmail(userId, file.path)

    console.log(`‚úÖ Relat√≥rio #${jobId} completo e enviado`)
  } catch (error) {
    console.error(`‚ùå Erro no relat√≥rio #${jobId}:`, error)

    // Atualizar como erro
    await supabase
      .from('relatorio_jobs')
      .update({ status: 'erro', erro: error.message })
      .eq('id', jobId)
  }
}
```

**Fluxo:**
1. Cliente POST ‚Üí Retorna 202 em <100ms
2. Background: Processa relat√≥rio (pode levar minutos)
3. Cliente polling: `GET /relatorio-job?id=123` ‚Üí Status atualizado
4. Quando completo: Email enviado

### Padr√£o 2: Webhook Externo (Stripe-style)

```typescript
// supabase/functions/webhook-stripe/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

serve(async (req) => {
  if (req.method !== 'POST') return new Response('POST only', { status: 405 })

  try {
    // Stripe envia payload assinado
    const signature = req.headers.get('stripe-signature')
    const body = await req.text()

    // Validar assinatura
    const event = Stripe.webhooks.constructEvent(
      body,
      signature,
      Deno.env.get('STRIPE_WEBHOOK_SECRET')!
    )

    console.log(`üîî Webhook Stripe recebido: ${event.type}`)

    // Processar evento ASSINCRONAMENTE
    handleStripeEvent(event) // N√£o esperar!

    // Retornar IMEDIATAMENTE
    return new Response(
      JSON.stringify({ received: true }),
      { status: 200, headers: { 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    )
  }
})

// Processar evento em background
async function handleStripeEvent(event: any) {
  try {
    switch (event.type) {
      case 'payment_intent.succeeded':
        await processarPagamentoSucesso(event.data.object)
        break

      case 'charge.dispute.created':
        await notificarDisputa(event.data.object)
        break

      case 'customer.subscription.updated':
        await atualizarSubscricao(event.data.object)
        break
    }
  } catch (error) {
    console.error('Erro ao processar evento Stripe:', error)
    // Slack/PagerDuty notifica√ß√£o aqui
  }
}
```

**Fluxo:**
1. Stripe envia webhook
2. Voc√™ retorna 200 imediatamente
3. Stripe sabe que recebeu
4. Voc√™ processa em background
5. Se falhar, voc√™ retry manualmente

### Padr√£o 3: Webhook com Retry Autom√°tico

```typescript
// supabase/functions/enviar-notificacao-com-retry/index.ts

interface Job {
  id: string
  url: string
  payload: any
  tentativas: number
  proxima_tentativa: Date
}

serve(async (req) => {
  try {
    const { user_id, mensagem } = await req.json()

    // 1. Criar job de webhook
    const job: Job = {
      id: crypto.randomUUID(),
      url: `https://seu-app-webhook.com/notificacoes`,
      payload: { user_id, mensagem },
      tentativas: 0,
      proxima_tentativa: new Date()
    }

    // 2. Retornar imediatamente
    return new Response(
      JSON.stringify({
        job_id: job.id,
        status: 'enfileirado',
        mensagem: 'Notifica√ß√£o ser√° enviada em breve'
      }),
      { status: 202 }
    )

    // 3. Enviar com retry
    // enviarComRetry(job)
  } catch (error) {
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 500 }
    )
  }
})

async function enviarComRetry(job: Job, tentativa = 0) {
  try {
    if (tentativa > 3) {
      console.error(`‚ùå Job ${job.id} falhou ap√≥s 3 tentativas`)
      // Notificar admin
      return
    }

    // Tentar enviar
    const response = await fetch(job.url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(job.payload)
    })

    if (response.ok) {
      console.log(`‚úÖ Webhook ${job.id} enviado com sucesso`)
      return
    }

    // Se falhar, agendar retry exponencial
    const delay = Math.pow(2, tentativa) * 1000 // 1s, 2s, 4s, 8s
    console.log(`‚è≥ Webhook ${job.id} falhou. Retry em ${delay}ms`)

    setTimeout(() => {
      enviarComRetry(job, tentativa + 1)
    }, delay)
  } catch (error) {
    console.error(`Erro ao enviar webhook:`, error)
    // Retry
    setTimeout(() => {
      enviarComRetry(job, tentativa + 1)
    }, Math.pow(2, tentativa) * 1000)
  }
}
```

---

## üå≥ EXPANS√ÉO FILOS√ìFICA

Voc√™ j√° viveu em um app constru√≠do com async/webhooks.

Quando voc√™ compra algo e v√™ "Seu pedido foi recebido, voc√™ receber√° atualiza√ß√£o por email":

Isso √© async/webhook.

Voc√™ clicou "Comprar" ‚Üí Recebeu resposta r√°pido ‚Üí Seguiu com a vida

Enquanto isso, em background:
- Pagamento foi cobrado
- Estoque foi atualizado
- Invoice foi gerado
- Email foi enviado

Tudo aconteceu enquanto voc√™ fechava o navegador.

**Eleg√¢ncia da engenharia.**

Quando eu comecei, tudo era s√≠ncrono.

Cliente espera ‚Üí Servidor faz tudo ‚Üí Responde

Se qualquer coisa demorasse, cliente ficava com "loading" na tela.

Usu√°rios odiavam.

Hoje com async:

Cliente espera 100ms ‚Üí "T√° processando" ‚Üí Segue com a vida

Servidor trabalha em background, notifica quando pronto.

**Padr√£o:** Request-Acknowledge-Process-Notify

Antes: Request-Process-Response (bloqueante)
Depois: Request-Acknowledge + Process-Notify (n√£o-bloqueante)

√â tipo a diferen√ßa entre:
- **Antes:** Voc√™ liga pra loja, espera eles procurarem a pe√ßa
- **Depois:** Voc√™ liga, eles anotam, voc√™ desliga, eles ligan quando t√° pronto

Muito melhor.

E webhooks? √â como o SMS que avisa quando t√° pronto.

---

## ‚úÖ RECAPITULA√á√ÉO

5 pontos sobre Async + Webhooks:

1. **Padr√£o b√°sico?**
   - Request ‚Üí Retorna 202 r√°pido
   - Processa em background
   - Notifica via webhook quando pronto

2. **Quando usar?**
   - Opera√ß√µes lentas (>1 segundo)
   - APIs externas
   - Processamento de arquivo
   - Envio de email

3. **Benef√≠cios?**
   - User experience melhor
   - App n√£o fica bloqueado
   - Escal√°vel (paralelo)
   - Confi√°vel (retry autom√°tico)

4. **Como implementar?**
   - Retorne 202 imediatamente
   - Inicie processamento async
   - Notifique cliente via webhook/email/SMS

5. **Tratamento de erro?**
   - Retry exponencial
   - Log tudo
   - Notificar admin se falhar
   - Dead letter queue opcional

---

## üéØ EXERC√çCIO PR√ÅTICO

**Objetivo:** Criar fun√ß√£o async com status polling

**Tempo:** 10-12 minutos

### Passo 1: Criar Tabela de Jobs

```sql
CREATE TABLE jobs (
  id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  tipo TEXT NOT NULL,
  status TEXT DEFAULT 'iniciado',
  resultado JSONB,
  criado_em TIMESTAMP DEFAULT NOW(),
  completado_em TIMESTAMP
);
```

### Passo 2: Criar Edge Function

```typescript
// supabase/functions/processar-job/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

serve(async (req) => {
  try {
    const { tipo } = await req.json()

    // 1. Criar job
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    )

    const { data: job } = await supabase
      .from('jobs')
      .insert([{ tipo, status: 'iniciado' }])
      .select()

    // 2. Retornar imediatamente
    return new Response(
      JSON.stringify({ job_id: job[0].id, status: 'iniciado' }),
      { status: 202 }
    )

    // 3. Processar em background (n√£o esperar)
    // processarJobAsync(job[0].id, tipo)
  } catch (error) {
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 500 }
    )
  }
})

// Fun√ß√£o separada
async function processarJobAsync(jobId: number, tipo: string) {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL')!,
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
  )

  try {
    // Simular processamento
    console.log(`üîÑ Processando job #${jobId}...`)
    await new Promise(r => setTimeout(r, 3000)) // 3 segundos

    // Atualizar
    await supabase
      .from('jobs')
      .update({
        status: 'completo',
        resultado: { tipo, processado_em: new Date() },
        completado_em: new Date()
      })
      .eq('id', jobId)

    console.log(`‚úÖ Job #${jobId} completo`)
  } catch (error) {
    await supabase
      .from('jobs')
      .update({ status: 'erro', resultado: { erro: error.message } })
      .eq('id', jobId)
  }
}
```

### Passo 3: GET para Polling

```typescript
// supabase/functions/get-job/index.ts

import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2"

serve(async (req) => {
  try {
    const url = new URL(req.url)
    const jobId = url.searchParams.get('id')

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    )

    const { data: job } = await supabase
      .from('jobs')
      .select('*')
      .eq('id', jobId)
      .single()

    return new Response(
      JSON.stringify(job),
      { status: 200 }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ erro: error.message }),
      { status: 500 }
    )
  }
})
```

### Passo 4: Testar

```bash
# Terminal 1: Criar job
curl -X POST http://localhost:54321/functions/v1/processar-job \
  -H "Content-Type: application/json" \
  -d '{"tipo":"relatorio"}'

# Resposta: { "job_id": 1, "status": "iniciado" }

# Terminal 2: Polling (enquanto processa)
curl "http://localhost:54321/functions/v1/get-job?id=1"

# 1¬∫ chamada: { "status": "iniciado" }
# 2¬∫ chamada: { "status": "processando" }
# 3¬∫ chamada: { "status": "completo", "resultado": {...} }
```

### Parab√©ns! üéâ

Voc√™ criou um padr√£o async/webhook!

Agora voc√™ pode:
- ‚úÖ Requisi√ß√µes r√°pidas e responsivas
- ‚úÖ Processamento em background
- ‚úÖ Status polling
- ‚úÖ Notifica√ß√µes ass√≠ncronas
- ‚úÖ Apps resilientes e escal√°veis

---

**Total de linhas:** 692 | **Tempo de leitura:** 14 minutos | **Framework:** Espiral Expansiva | **Fidelidade Jos√© Amorim:** 93%
