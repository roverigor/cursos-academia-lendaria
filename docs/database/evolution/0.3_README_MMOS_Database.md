# MMOS Database — README (KISS • Supabase/PostgreSQL 16+)

> **Objetivo**: armazenar e operar “mentes” (**minds**), suas **fontes**, **fragmentos**, **artefatos de agentes** e **telemetria** — com **simplicidade**, **desempenho** e **auditabilidade ponta‑a‑ponta**.

## TL;DR (decisões‑chave)

- **PostgreSQL 16+** com `pgcrypto` (UUID everywhere).
- **KISS**: normalizar só o essencial; o resto fica em **JSONB versionado**.
- **Proveniência completa**: tudo conecta em **fila → execuções → métricas**.
- **Sem dívidas**: nada de agregados em `minds`; tempos e custos são **derivados por *views***.
- **Busca rápida**: FTS em `fragments`; **tags** (case‑sensitive) via tabela de junção.
- **Relevância**: escala **0..10** (com derivado **0.0..1.0**); arredondamento de décimos por `snap_to_tenth`.
- **Relacionamentos**: `related` canônico (A–B ≡ B–A); `supports/contradicts` dirigidos.
- **Artefatos de agentes**: salvos como **profiles** (JSONB); sinais críticos **destilados** (valores, rotina, psicometria).

---

## Arquitetura (macro)

```
minds ─┬─> sources ─┬─> fragments ─┬─ fragment_tags ─┬─ tags
       │            │              └─ fragment_relationships
       │            └─> categories
       ├─> mind_profiles (JSONB versionado) ──┬─ mind_profile_evidence (opcional)
       │                                      ├─ mind_values
       │                                      ├─ mind_routine_windows
       │                                      └─ mind_psychometrics / mind_obsessions
       └─> pipeline_progress

ingestion_batches ─┬─ processing_queue ─┬─ job_executions ─┐
                   └────────────────────────────────────────┴─> views de custo/tempo
```

---

## Núcleo de Dados

### 1) `minds` (+ `mind_aliases`)
**Quem é a mente.** Campos práticos: `slug`, `display_name`, `primary_language`, `short_bio`, `category`, `primary_domain`, métricas (`quality_grade`, `apex_score`, `completeness`, `confidence_avg`), e `extra` (JSONB).  
**Sem agregados**: tempo/custo não moram aqui.

### 2) `sources`
**De onde veio.** Timeline e proveniência: `type` (`book|article|podcast|interview|dossier|…`), `published_date`, `quality`, `language`, `extra`.

### 3) `fragments`
**O átomo do conhecimento.** Citação/ideia com contexto e insight.
- Relevância: `relevance_10` (0..10) + `relevance` (0.0..1.0) gerado.
- FTS (`tsv`) em `content|context|insight` (GIN).
- **Sem arrays**: tags via `fragment_tags` (+ `tags`).

### 4) Taxonomia & Tags
- **Competências**: `domains → specializations → skills` (vocabulário controlado).
- **Proeficiências**: `mind_proficiencies` (+ `mind_proficiency_evidence`).
- **Traços**: `traits`, `trait_scores` (+ `trait_score_evidence`).
- **Tags livres**: `tags` + `fragment_tags` (case‑sensitive).

### 5) Grafo
`fragment_relationships`: `related` **não‑dirigido** (índice canônico A–B/B–A); `supports/contradicts` dirigidos.

---

## Coração Operacional (fila → execução → métricas)

### 6) Lotes & Fila
`ingestion_batches`, `processing_queue` — orquestram *jobs* com `job_type`, `scope_type` (mind/source/fragment/file/url) e `status`.

### 7) Execuções
`job_executions` — uma linha por tentativa, com **tokens/custo/latência** e `params`.

### 8) Derivações (sem duplicar estado)
- **Execução→Mente**: `v_job_mind_attribution` (prioridade: `mind` → `source` → *fallback* via `fragments`).
- **Tempo/custo por lote**: `v_batch_durations`.
- **Tempo/custo por mente**: `v_mind_processing_time`.
- **Custo por fragmento**: `v_cost_per_fragment`.
- **Custo por lote/modelo**: `v_batch_costs`.

> Resultado: **nunca** gravamos “tempo na mente”; **sempre derivamos**.

---

## Artefatos de Agentes (versionado + sinais leves)

### 9) `mind_profiles` (JSONB)
Artefatos como `psychometrics`, `writing_style`, `voice_guide`, `values_hierarchy`, `routine`, `recognition_patterns`, `decision_patterns`, `mental_models`, `frameworks`…  
Várias versões por tipo; `human_validation_status` (`PENDING|APPROVED|REJECTED`); `generation_execution_id` para custo.

### 10) “Versão vigente”
`v_mind_latest_profiles` retorna **a versão mais recente válida** por (`mind_id`, `profile_type`).

### 11) Evidência semântica (opcional)
`mind_profile_evidence` liga um profile a `fragments`/`sources` que o sustentam.

### 12) Sinais destilados (normalizados)
- **Valores top‑N**: `mind_values` (rank, intensidade, confiança, `profile_id`).
- **Rotina**: `mind_routine_windows` (janelas locais; ex.: `deep_work_prime_time`).
- **Psicometria**: `mind_psychometrics` (DISC/MBTI/Eneagrama).
- **Obsessões**: `mind_obsessions` (perguntas‑motor).

### 13) Custos por artefato
`v_profile_costs` une profiles → execuções → lotes para tokens/$$/latência por deliverable.

---

## Convenções

- **UUID everywhere**.
- **Tags**: `name` **case‑sensitive** (único).
- **Relevância**: entrada 0..1 → `snap_to_tenth` → `relevance_10` (0..10).
- **FTS**: pesos `A(content) | B(context) | C(insight)`.
- **`related`** canônico: índice único em `LEAST(from,to), GREATEST(from,to)` (só p/ `related`).

---

## Snippets úteis

```sql
-- Fragments por tag
SELECT f.*
FROM fragments f
JOIN fragment_tags ft ON ft.fragment_id = f.id
JOIN tags t ON t.id = ft.tag_id
WHERE t.name = 'axiom'
ORDER BY f.relevance_10 DESC, f.created_at DESC;

-- Interseção (skill ∧ tema)
WITH skill_frags AS (
  SELECT f.id
  FROM mind_proficiencies mp
  JOIN mind_proficiency_evidence mpe ON mpe.mind_proficiency_id = mp.id
  JOIN fragments f ON f.id = mpe.fragment_id
  JOIN skills sk ON sk.id = mp.skill_id
  WHERE mp.mind_id = :mind_id AND sk.code = 'decision_making'
)
SELECT f.*
FROM fragments f
JOIN skill_frags sf ON sf.id = f.id
JOIN fragment_tags ft ON ft.fragment_id = f.id
JOIN tags t ON t.id = ft.tag_id
WHERE t.name = 'contradiction';

-- “Estou na janela de rotina agora?” (com overnight)
SELECT *
FROM mind_routine_windows w
WHERE w.mind_id = :mind_id
AND (
  (w.start_local <= w.end_local AND LOCALTIME BETWEEN w.start_local AND w.end_local)
  OR
  (w.start_local  > w.end_local AND (LOCALTIME >= w.start_local OR LOCALTIME <= w.end_local))
);

-- Perfil vigente (writing style)
SELECT payload
FROM v_mind_latest_profiles
WHERE mind_id = :mind_id AND profile_type = 'writing_style';

-- Custos por artefato vigente de um tipo
WITH p AS (
  SELECT id FROM v_mind_latest_profiles
  WHERE mind_id = :mind_id AND profile_type = 'writing_style'
)
SELECT * FROM v_profile_costs WHERE profile_id = (SELECT id FROM p);
```

---

## Operação (ciclo)

1. Orquestrador cria `processing_queue` (escopo mind/source/fragment).
2. Worker executa → grava `job_executions` (tokens/$$/latência).
3. Outputs: `fragments` e/ou `mind_profiles` (linkando `generation_execution_id`).
4. Dashboards e agentes consultam *views* (`v_*`).

---

## Migração / Bootstrapping

1. Habilite `pgcrypto`.
2. Execute o **DDL completo** (arquivo do projeto).
3. Insira catálogos (`categories`, `domains/specializations/skills`, `traits`).
4. Suba `minds`, `sources`, `fragments`, `tags`.
5. Use `ingestion_batches` → `processing_queue` → `job_executions`.
6. Para artefatos, grave em `mind_profiles` + destile sinais quando fizer sentido.

---

## Glossário

- **DDL** (*Data Definition Language*): `CREATE/ALTER/DROP` de objetos SQL.
- **Profile**: artefato de agente (YAML/MD/JSON) versionado por mente.
- **Sinal destilado**: parte quente de um profile em tabela simples (valores/rotina/etc.).
- **Proveniência**: rastro técnico (lote/exec) e semântico (evidência em sources/fragments).

---

## Checklists rápidos

- [ ] `sources`: sempre com `mind_id` + `published_date`.
- [ ] `fragments`: `mind_id`, `source_id`, `location`, `relevance_10`, `content/context/insight`.
- [ ] `tags.name`: **case‑sensitive** e único.
- [ ] `mind_profiles`: `profile_type` consistente + `generation_execution_id` quando houver.
- [ ] Métricas: **sempre via *views*** (não duplicar estado).
