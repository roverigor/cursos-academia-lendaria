# AIOS Unified Database — README (KISS, Supabase/PostgreSQL 16+)

Este documento explica o **esquema completo** que você acabou de aplicar:
- Core de conhecimento (**minds → sources → fragments**)
- Enriquecimentos (**tags**, **relationships**, **taxonomia/traits**, **profiles**)
- Operacional (**ingestion_batches → processing_queue → job_executions**)
- CreatorOS (**content_projects → content_pieces → campaigns/performance**)
- Auth & RLS (**Magic Link** + mapeamento `auth.users → user_profiles → mind`)
- Índices, FTS, Views, e *operational analytics*

> Filosofia: **KISS**. Evitar débito técnico, rodar rápido e com rastreabilidade total.
> Decisões extensíveis sem *breaking changes* (adicionar colunas/tabelas é simples).

---

## 1) Visão Geral (mental model)

**Raiz única:** `minds`  
**Proveniência:** `sources` (cada mind tem fontes) → `fragments` (trechos destilados)  
**Enriquecimento:** `tags` (N:M), `fragment_relationships` (grafo), `domains/specializations/skills`, `traits`  
**Artefatos de síntese:** `mind_profiles` (+ *evidence*), destilados (`mind_values`, `mind_routine_windows`, `mind_psychometrics`, `mind_obsessions`)  
**Operacional:** `ingestion_batches` → `processing_queue` → `job_executions` (+ métricas tokens/custo)  
**CreatorOS:** `content_projects` (creator_mind ▶ persona_mind) → `content_pieces` → `content_campaigns` + `content_performance`  
**Auth & RLS:** `user_profiles(id = auth.users.id, mind_id)` + **políticas mínimas** e **defaults** (cliente não envia `mind_id`).

---

## 2) Entidades principais (o que importa no dia 1)

### minds
- Identidade do “sujeito” (pessoa/voz) que estamos representando.
- Campos chave: `slug`, `display_name`, `primary_language`, `short_bio`, `privacy_level`.
- **Por quê:** tudo se ancora na mente; facilita queries cruzadas e RLS.

### sources
- Fontes originais: livro, artigo, podcast, entrevista, dossiê, link web.
- Campos chave: `mind_id`, `title`, `type`, `published_date`, `language`, `quality`.

### fragments
- Núcleo do conhecimento destilado (sem arrays).
- Campos chave: `mind_id`, `source_id`, `category_id`, `location`, `type`, `relevance_10`, `content/context/insight`.
- **FTS** nativo (`tsv` com GIN). Índices para hot paths (por `mind_id`, `source_id`, `relevance_10`, `created_at`).

### tags & fragment_tags
- *Registry* de tags **case-sensitive** e a junction table **N:M**.
- **Por quê:** busca por tag em **5–20ms** com índices, escalável a milhões.

### fragment_relationships
- Relações A→B (`supports`, `contradicts`) e A—B (`related` canônico com índice único).
- **Por quê:** permite *latticework* e navegação semântica multi-hop.

---

## 3) Taxonomia & Traits (opcional, pronto para uso)

- `domains → specializations → skills` + `mind_proficiencies` (+ evidências).
- `traits` (ex.: Big Five) + `trait_scores` (+ evidências).  
> Mantidos **simples**, prontos para escalar quando houver dados suficientes.

---

## 4) Artefatos de Perfil (MMOS)

- `mind_profiles` (documentos YAML/JSON/MD versionados, por tipo: `psychometrics`, `writing_style`, `voice_guide`, `values_hierarchy`, `routine`, etc.).
- Evidências: `mind_profile_evidence` (liga profile ↔ fragment/source).
- Destilados: `mind_values`, `mind_routine_windows`, `mind_psychometrics`, `mind_obsessions`.

**Por quê:** armazena a camada rica **sem** espalhar colunas; destilações surgem depois com necessidade.

---

## 5) Operacional (fila → execuções → métricas)

- `ingestion_batches`: metadados de *pipeline* e LLM pretendido.
- `processing_queue`: orquestração de jobs (prioridade/estado/timestamps).
- `job_executions`: **telemetria real** (tokens, custo, latência, modelo usado).

**Linkagem:** artefatos (ex.: `fragments.generation_execution_id`) apontam para a execução que os gerou → *views* somam custos por lote, modelo, mente.

---

## 6) CreatorOS (conteúdo)

- `content_projects`: **quem cria** (`creator_mind_id`) e **qual voz** (`persona_mind_id`).  
- `content_pieces`: peça de conteúdo (blog, post, newsletter, roteiro…), opcionalmente ligada a `job_executions` para proveniência.  
- `content_campaigns` + `content_campaign_pieces`: agrupamento/planejamento.  
- `content_performance`: métricas coletadas (views, engajamento, conversões…).  
- (opcional P2) `content_frameworks` + `framework_id` em `content_pieces` (AIDA/GPS etc.).

**Por quê:** captura o ciclo **planejar → gerar → publicar → medir** com proveniência.

---

## 7) Auth & RLS (passwordless, anti-atrito)

### Login mais simples: **Magic Link (passwordless)**
- Ative “Email → Magic Link/OTP” no Supabase, configure Redirect URL.
- Front usa `signInWithOtp({ email, options: { emailRedirectTo: ... }})`.

### Mapeamento usuário ↔ mind (zero backend)
- `user_profiles(id = auth.users.id, mind_id)`
- Trigger `provision_user_profile` cria uma nova `mind` e o `user_profile` no primeiro signup (slug = parte do e-mail).

### RLS mínima (1 policy por tabela + defaults)
- `DEFAULT current_mind_id()` nas colunas `mind_id`/`creator_mind_id` → **o cliente não envia `mind_id`**.
- `FOR ALL USING (mind_id = current_mind_id()) WITH CHECK (mind_id = current_mind_id())` nos objetos de cliente.
- **Operacional** sem RLS (só service-role).

**Modo DEV/QA**: crie `dev_open.sql` com `USING(true) WITH CHECK(true)` e `dev_close.sql` para remover, sem reescrever policies.

---

## 8) Views principais (analíticas)

- `v_job_mind_attribution`: atribui execuções à mente (prioridade: mind → source → fragment).
- `v_batch_durations`: soma de duração por lote.
- `v_mind_processing_time`: tempo gasto por mente (derivado da fila).
- `v_cost_per_fragment`, `v_batch_costs`: custos e tokens por artefato/lote/modelo.
- `v_mind_latest_profiles`: última versão válida por (mind, profile_type).
- `v_project_content_stats`, `v_content_performance_agg`: CreatorOS.

**Princípio:** **zero duplicação de estado**; tudo derivado de execuções/filas/artefatos.

---

## 9) Índices e FTS (performance-first)

- `fragments.tsv` com **GIN** + pesos A/B/C (content/context/insight).  
- Hot paths:  
  - `idx_frag_mind_rel10_desc (mind_id, relevance_10 DESC)`  
  - `idx_frag_source_created (source_id, created_at DESC)`
- Cobertura: `fragment_tags` com `INCLUDE` para *covering index* (evita *heap fetch*).
- Grafo canônico: `ux_related_canonical` evita duplicidade A—B.

**Regra de ouro:** antes de otimizar mais, rode `EXPLAIN ANALYZE` e crie índice **para a query**, não o inverso.

---

## 10) Fluxos comuns (exemplos)

### 10.1 Inserir um fragment (cliente)
- Login com Magic Link (JWT no front).  
- `INSERT INTO sources (title, type, published_date, quality) VALUES (...)` — `mind_id` vem por **DEFAULT**.  
- `INSERT INTO fragments (source_id, category_id, location, type, relevance_10, content, context, insight)` — idem.

### 10.2 Taggear um fragment
- `INSERT INTO tags(name, tag_type) VALUES ('leverage','theme') ON CONFLICT DO NOTHING;`
- `INSERT INTO fragment_tags(fragment_id, tag_id) VALUES (..., ...)`.

### 10.3 Timeline por tema
```sql
SELECT s.published_date, s.title, f.id, f.content
FROM fragments f
JOIN sources s ON s.id = f.source_id
JOIN fragment_tags ft ON ft.fragment_id = f.id
JOIN tags t ON t.id = ft.tag_id
WHERE t.name = 'success'
ORDER BY s.published_date ASC;
```

### 10.4 Custos por lote
```sql
SELECT * FROM v_batch_costs ORDER BY last_exec_at DESC;
```

### 10.5 Conteúdo por projeto e performance
```sql
SELECT * FROM v_project_content_stats ORDER BY last_published_at DESC;
SELECT * FROM v_content_performance_agg ORDER BY total_value DESC;
```

---

## 11) Migração (SQLite → Supabase)

Use o script KISS:
- `/mnt/data/migrate_sqlite_to_supabase.py`  
  - Mapeia `minds`, `sources`, `categories`, `fragments`, `tags`, `fragment_tags`.
  - Faz *lookups* por `slug/title/code`, usa `ON CONFLICT` para idempotência.

**Rodar:**
```bash
export SQLITE_PATH=./SQLite legado (migrado para Supabase em 2025-10)
export PG_DSN="postgresql://USER:PASS@HOST:5432/DB"
python /mnt/data/migrate_sqlite_to_supabase.py
```

---

## 12) Checklists

**Deploy:**
- [ ] Aplicar DDL completo (este projeto).  
- [ ] Ver *views* com `SELECT` para garantir que não quebraram.  
- [ ] Rodar *smoke tests* (o do core e o do CreatorOS).

**Auth:**
- [ ] Habilitar **Magic Link** e URLs de redirect.  
- [ ] Confirmar trigger `trg_provision_user_profile`.  
- [ ] Testar `SELECT auth.uid(), current_mind_id();` logado.

**RLS:**
- [ ] Defaults `current_mind_id()` nas colunas que o cliente cria.  
- [ ] 1 policy `FOR ALL` por tabela.  
- [ ] Operacional sem RLS (só service-role).

**Perf:**
- [ ] `EXPLAIN ANALYZE` nas top-queries (tags/timeline/FTS).  
- [ ] Ajustar índices conforme uso real.

---

## 13) Troubleshooting rápido

- **INSERT negado**? Verifique `WITH CHECK` (provável falta de `current_mind_id()` ou policy).  
- **SELECT vazio**? Confira `auth.uid()` e `current_mind_id()` no contexto do JWT.  
- **Upsert “não atualiza”**? `UPDATE` também checa `WITH CHECK`.  
- **Service key no front**? Nunca. Use `anon` no front; `service` apenas em server/Edge Functions.  
- **Fila/execuções invisíveis**? Esperado (sem RLS, apenas service-role).

---

## 14) Roadmap seguro (sem refactor pesada)

- RLS refinada (papéis de time: `mind_members(user_id, mind_id, role)`).
- Auditoria opcional (`audit_log` + triggers).  
- Enriquecimentos de CreatorOS (frameworks, attribution, SEO tracking).  
- Funções STABLE para *query libraries* (RPCs).  
- Storage buckets (avatars, sources originais) e Realtime (para dashboards).

---

## 15) Decisões-chave (resumo)

- **Single schema** (`public`) para evitar silos.  
- **Mind como raiz** (consistência conceitual).  
- **Proveniência completa** (lot → queue → execution → artifacts).  
- **JSONB-first** para perfis (sem colunar cedo).  
- **RLS mínima** com `DEFAULT current_mind_id()` (cliente não envia `mind_id`).  
- **Índices apenas quando ajudam** (baseados em queries reais).

---

## 16) Snippets úteis

### Obter minha mind no app (Supabase JS)
```ts
const { data: myMindId } = await supabase.rpc('current_mind_id')
```

### Abrir/fechar RLS em DEV
```sql
-- dev_open.sql
CREATE POLICY dev_open_fragments ON fragments FOR ALL TO authenticated USING (true) WITH CHECK (true);

-- dev_close.sql
DROP POLICY IF EXISTS dev_open_fragments ON fragments;
```

---

**Pronto.** Você tem um banco unificado, simples, rastreável e extensível.  
Se quiser, eu também entrego um **ERD mermaid** e um **script de seed** maior com dados sintéticos realistas para testes de carga.
