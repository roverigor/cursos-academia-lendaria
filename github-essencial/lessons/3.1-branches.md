# 3.1 - Branches

**Duração:** 12 min | **Nível:** Iniciante

## Objetivo

Entender por que usar branches, como criar e gerenciar branches, e seguir convenções de nomenclatura profissionais.

## Por que isso importa

Branches são a base da colaboração em Git. Permitem desenvolver features isoladamente, proteger código de produção e trabalhar em paralelo sem conflitos. Todo time profissional usa branches - é o jeito certo de colaborar.

## Conteúdo

### O Que São Branches?

**Branch:** Linha independente de desenvolvimento.

**Analogia:**
- `main` = Rodovia principal (sempre estável)
- Branches = Vias paralelas onde você constrói/testa
- Merge = Retornar para rodovia principal depois de pronto

```
main:     A---B---C---F---G
               \       /
feature:        D-----E
```

**Isolamento:** Mudanças em `feature` não afetam `main` até merge.

### Por Que Usar Branches?

#### 1. Proteção do Código Estável

```bash
main (produção)  ← Sempre funcional, nunca quebra
 │
 ├── feature/login  ← Experimente à vontade
 ├── fix/bug-123    ← Correções isoladas
 └── refactor/api   ← Refatorações sem risco
```

#### 2. Trabalho Paralelo

```bash
main
 ├── alice/dashboard   (Alice trabalhando)
 ├── bob/authentication (Bob trabalhando)
 └── carol/api-v2      (Carol trabalhando)
```

Todos trabalham simultaneamente sem interferência.

#### 3. Code Review Antes de Integrar

```bash
feature → Pull Request → Review → Aprovado → Merge para main
```

Nada entra em `main` sem revisão.

#### 4. Experimentos Seguros

```bash
# Testar ideia radical
git checkout -b experiment/new-architecture

# Se funcionar: merge
# Se falhar: delete branch, main intocada
```

### Visualizando Branches

```
        ┌────────────────────────────────┐
        │  main (branch padrão)          │
        │  └─ Código de produção         │
        └────────────┬───────────────────┘
                     │
        ┌────────────┴───────────────────┐
        │                                │
    ┌───▼─────────────────┐    ┌────────▼────────────────┐
    │  feature/login      │    │  fix/navbar-bug         │
    │  └─ Nova feature    │    │  └─ Correção urgente    │
    └─────────────────────┘    └─────────────────────────┘
```

### Comandos Básicos de Branch

#### Ver branches existentes

```bash
# Listar branches locais
git branch

# Saída:
* main
  feature/login
  fix/bug-123
```

O `*` indica branch atual.

```bash
# Listar todas (locais + remotas)
git branch -a

# Saída:
* main
  feature/login
  remotes/origin/main
  remotes/origin/feature/login
```

#### Criar nova branch

```bash
# Criar mas não mudar
git branch feature/dashboard

# Criar e mudar automaticamente (recomendado)
git checkout -b feature/dashboard

# Novo comando (Git 2.23+)
git switch -c feature/dashboard
```

**Equivalente a:**
```bash
git branch feature/dashboard
git checkout feature/dashboard
```

#### Mudar de branch

```bash
# Método tradicional
git checkout main

# Método novo (Git 2.23+, mais claro)
git switch main
```

**ATENÇÃO:** Mudanças não commitadas vêm junto! Commit ou stash antes.

#### Deletar branch

```bash
# Deletar branch local (só se já fez merge)
git branch -d feature/login

# Forçar delete (mesmo sem merge)
git branch -D experiment/failed

# Deletar branch remota
git push origin --delete feature/login
```

### Convenções de Nomenclatura

#### Formato Padrão: `type/description`

| Tipo | Uso | Exemplo |
|------|-----|---------|
| `feature/` | Nova funcionalidade | `feature/user-authentication` |
| `fix/` ou `bugfix/` | Correção de bug | `fix/login-redirect-loop` |
| `hotfix/` | Correção urgente de produção | `hotfix/payment-crash` |
| `refactor/` | Refatoração | `refactor/extract-auth-service` |
| `docs/` | Apenas documentação | `docs/update-readme` |
| `test/` | Adicionar testes | `test/add-auth-tests` |
| `chore/` | Tarefas de manutenção | `chore/update-dependencies` |

#### Boas Práticas de Nome

**✅ Bom:**
```
feature/dark-mode-toggle
fix/navbar-mobile-overflow
hotfix/critical-security-patch
refactor/split-large-components
```

**❌ Ruim:**
```
branch1             (sem contexto)
test                (muito genérico)
fixing-stuff        (vago)
FEATURE_NEW_THING   (não use CAPS/underscore)
my-branch           (não é sobre você, é sobre o trabalho)
```

**Regras:**
- Use kebab-case: `feature/user-profile`
- Seja descritivo mas conciso
- Prefixo com tipo
- Sem espaços ou caracteres especiais
- Em inglês (padrão da indústria)

### Workflow de Branch

#### Cenário: Adicionar nova feature

```bash
# 1. Certifique que main está atualizado
git checkout main
git pull

# 2. Crie branch a partir de main
git checkout -b feature/user-dashboard

# 3. Trabalhe normalmente
# ... edite arquivos ...
git add .
git commit -m "Add dashboard layout"

# ... mais commits ...
git commit -m "Add user stats widget"

# 4. Push da branch para GitHub
git push -u origin feature/user-dashboard

# 5. Abra Pull Request no GitHub
# (próxima lição)

# 6. Após aprovação e merge, delete branch local
git checkout main
git pull  # Atualiza com merge
git branch -d feature/user-dashboard
```

### Branch `main` vs `master`

**História:** Git usava `master` como padrão até 2020.

**Mudança:** GitHub e Git mudaram padrão para `main` (mais inclusivo).

**Hoje:**
- Projetos novos: `main`
- Projetos antigos: podem ter `master`
- Ambos funcionam igual tecnicamente

**Renomear master → main:**
```bash
# No projeto local
git branch -m master main
git push -u origin main

# No GitHub: Settings → Branches → Default branch → Change to main
# Depois delete master remota
git push origin --delete master
```

### Sincronizando Branches

#### Atualizar branch com mudanças de main

Cenário: Você está em `feature/login`, mas `main` teve commits novos.

```bash
# Método 1: Merge (cria merge commit)
git checkout feature/login
git merge main

# Método 2: Rebase (histórico linear, recomendado)
git checkout feature/login
git rebase main
```

**Rebase reaplica seus commits sobre os novos de main:**
```
Antes:
main:     A---B---C---D
               \
feature:        E---F

Depois de rebase:
main:     A---B---C---D
                       \
feature:                E'---F'
```

#### Push de branch

```bash
# Primeira vez (cria branch remota)
git push -u origin feature/dashboard

# Pushes seguintes
git push
```

#### Pull de branch

```bash
# Atualizar branch atual
git pull

# Atualizar main sem mudar de branch
git fetch origin main:main
```

### Ver Diferenças Entre Branches

```bash
# Ver commits em feature que não estão em main
git log main..feature/login

# Ver arquivos diferentes
git diff main..feature/login

# Ver só nomes de arquivos diferentes
git diff --name-only main..feature/login
```

### Estratégias de Branch

#### Git Flow (tradicional)

```
main (produção)
 └─ develop (integração)
     ├─ feature/* (features)
     ├─ release/* (preparação release)
     └─ hotfix/* (correções urgentes)
```

**Use quando:** Times grandes, releases planejados.

#### GitHub Flow (simples, recomendado para começar)

```
main (produção)
 ├─ feature/*
 ├─ fix/*
 └─ hotfix/*
```

**Use quando:** Deploy contínuo, times pequenos/médios.

**Regras:**
1. `main` sempre estável
2. Crie branch para qualquer mudança
3. Merge via Pull Request após review
4. Delete branch após merge

### Troubleshooting

**Erro: "Please commit your changes or stash them before you switch branches"**

```bash
# Opção 1: Commit
git add .
git commit -m "WIP: working on feature"

# Opção 2: Stash (guardar temporariamente)
git stash
git checkout outra-branch
# ... trabalhe ...
git checkout branch-original
git stash pop  # Recupera mudanças
```

**Erro: "Branch already exists"**

```bash
# Use outro nome ou delete a antiga
git branch -d nome-existente
git checkout -b nome-existente
```

## Exercício Prático

```bash
cd github-practice-repo

# 1. Ver branches atuais
git branch
# Só deve ter main

# 2. Criar branch para nova feature
git checkout -b feature/add-greeting

# 3. Fazer mudança
echo "function greet(name) { return \`Hello, \${name}!\`; }" > greeting.js
git add greeting.js
git commit -m "Add greeting function"

# 4. Ver branches agora
git branch
# * feature/add-greeting
#   main

# 5. Push da branch
git push -u origin feature/add-greeting

# 6. Voltar para main
git checkout main

# 7. Ver que arquivo não existe em main
ls greeting.js
# Erro: arquivo não existe (está só na branch)

# 8. Voltar para feature
git checkout feature/add-greeting

# 9. Arquivo existe novamente
ls greeting.js
# greeting.js

# 10. Ver no GitHub
# Acesse repo no GitHub, veja dropdown de branches
# Sua branch feature/add-greeting deve aparecer
```

## Checkpoint

- [ ] Entendo que branches isolam desenvolvimento
- [ ] Sei criar branch: `git checkout -b feature/nome`
- [ ] Sei mudar de branch: `git checkout main`
- [ ] Sigo convenção: `type/description` em kebab-case
- [ ] Sempre crio branch para features/fixes
- [ ] Mantenho `main` estável sempre
- [ ] Sei deletar branches após merge

## Próxima lição

Você criou branch! Agora vamos aprender a propor suas mudanças profissionalmente com Pull Requests. → **3.2 - Pull Request**
