# Story 1.6: Performance Tuning Workflow

## Status
Draft

## Story
**As a** developer,
**I want** to identify and fix performance bottlenecks in my database,
**so that** my queries run fast and my application scales efficiently

## Acceptance Criteria
1. User can analyze slow queries from pg_stat_statements
2. User can run EXPLAIN ANALYZE on specific queries
3. Workflow identifies common performance issues (seq scans, missing indexes)
4. Workflow generates index recommendations
5. User can create optimization migrations interactively
6. Performance improvements are measured (before/after comparison)
7. RLS policy performance analyzed (auth.uid() wrapping)

## Tasks / Subtasks

- [ ] Create workflow YAML file: `performance-tuning-workflow.yaml` (AC: all)
  - [ ] Define workflow metadata (id, name, description, version)
  - [ ] Add step 1: Performance analysis entry point
  - [ ] Add step 2: Issue identification
  - [ ] Add step 3: Recommendation generation
  - [ ] Add step 4: Fix application (migrations)
  - [ ] Add step 5: Verification (before/after measurement)

- [ ] Integrate db-analyze-hotpaths task (AC: 1)
  - [ ] Map workflow to db-analyze-hotpaths.md
  - [ ] Enable pg_stat_statements extension
  - [ ] Find top 20 slow queries by mean execution time
  - [ ] Let user select queries to analyze (by number)
  - [ ] Run EXPLAIN ANALYZE with BUFFERS on selected queries
  - [ ] Generate index recommendations using index_advisor (Supabase)

- [ ] Integrate db-explain task (AC: 2)
  - [ ] Map workflow to db-explain.md for single query analysis
  - [ ] Run EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
  - [ ] Interpret key metrics:
    - [ ] Execution time (target: < 100ms interactive, < 1s reports)
    - [ ] Planning time
    - [ ] Cost estimates
    - [ ] Row count estimates vs actuals
    - [ ] Buffer cache hits vs disk reads
  - [ ] Highlight issues in output

- [ ] Integrate query-optimization task (AC: 3,4,5,6)
  - [ ] Map workflow to query-optimization.md for interactive optimization
  - [ ] Identify issues:
    - [ ] Sequential scans on large tables
    - [ ] Row count mismatches (10x+ difference)
    - [ ] Nested loops with high iterations
    - [ ] Buffer cache misses (high disk reads)
    - [ ] Temporary files (work_mem exceeded)
    - [ ] Sort operations on large datasets
  - [ ] Generate recommendations for each issue
  - [ ] Create optimization migration with proposed indexes
  - [ ] Test optimization (before/after execution time)
  - [ ] Calculate speedup (e.g., "99.2% faster")

- [ ] Add RLS performance check (AC: 7)
  - [ ] Integrate db-rls-audit task
  - [ ] Check for unwrapped auth.uid() in policies
  - [ ] Detect: `auth.uid() = user_id` (slow, 99.99% slower!)
  - [ ] Recommend: `(select auth.uid()) = user_id` (cached, fast!)
  - [ ] Show performance impact: 10,000x speedup
  - [ ] Generate migration to wrap auth functions

- [ ] Add index design guidance (AC: 4)
  - [ ] Single-column indexes for simple filters
  - [ ] Composite indexes for multiple filters + ORDER BY
  - [ ] Partial indexes for filtered queries (WHERE deleted_at IS NULL)
  - [ ] Expression indexes for function calls (LOWER(email))
  - [ ] Covering indexes (INCLUDE) for index-only scans
  - [ ] GIN indexes for JSONB/full-text search
  - [ ] B-tree vs Hash vs GiST vs GIN guidance

- [ ] Add performance benchmarking (AC: 6)
  - [ ] Measure baseline: execution time before optimization
  - [ ] Apply optimization (indexes, rewrites)
  - [ ] Measure after: execution time after optimization
  - [ ] Calculate improvement: speedup ratio, percentage
  - [ ] Display comparison table
  - [ ] Recommend re-running for consistency (warm cache)

- [ ] Add common optimization patterns (AC: 3,4)
  - [ ] Pattern 1: Simple filter ‚Üí single-column index
  - [ ] Pattern 2: Composite filter + sort ‚Üí multi-column index
  - [ ] Pattern 3: Join ‚Üí index on FK
  - [ ] Pattern 4: Partial index for soft-deleted tables
  - [ ] Pattern 5: Covering index for SELECT specific columns
  - [ ] Pattern 6: Expression index for function calls

- [ ] Test workflow end-to-end (AC: all)
  - [ ] Test hotpaths analysis (find slow queries)
  - [ ] Test EXPLAIN ANALYZE on specific query
  - [ ] Test issue identification (seq scan, row mismatch, etc.)
  - [ ] Test index recommendation generation
  - [ ] Test optimization migration creation
  - [ ] Test before/after performance measurement
  - [ ] Test RLS performance check (auth.uid() wrapping)
  - [ ] Test error handling (pg_stat_statements not enabled)

- [ ] Update db-sage agent (AC: all)
  - [ ] Add `*tune` command mapping to performance-tuning-workflow.yaml
  - [ ] Add `*hotpaths` command mapping to db-analyze-hotpaths.md
  - [ ] Add `*optimize` command mapping to query-optimization.md
  - [ ] Update commands list in db-sage.md
  - [ ] Update dependencies section

## Dev Notes

### Relevant Source Tree
```
expansion-packs/super-agentes/
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îî‚îÄ‚îÄ db-sage.md                           # Add *tune, *hotpaths, *optimize
‚îú‚îÄ‚îÄ workflows/
‚îÇ   ‚îî‚îÄ‚îÄ performance-tuning-workflow.yaml     # NEW FILE
‚îú‚îÄ‚îÄ tasks/
‚îÇ   ‚îú‚îÄ‚îÄ db-analyze-hotpaths.md               # Find slow queries
‚îÇ   ‚îú‚îÄ‚îÄ db-explain.md                        # EXPLAIN ANALYZE
‚îÇ   ‚îú‚îÄ‚îÄ query-optimization.md                # Interactive optimization
‚îÇ   ‚îî‚îÄ‚îÄ db-rls-audit.md                      # RLS performance check
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ epics/epic-db-sage-workflows.md
    ‚îî‚îÄ‚îÄ stories/1.6.performance-tuning-workflow.md
```

### Key Context from Research

**Industry Pattern (PostgreSQL 2024):**
- Always use EXPLAIN (ANALYZE, BUFFERS) for complete picture
- Measure before/after (don't guess performance)
- Index recommendations from pg_stat_statements analysis
- Regular ANALYZE to update statistics
- Monitor cache hit ratio (target: > 95%)

**From db-workflows-research-2024.md (Performance Phase):**

**Performance Optimization Workflow:**
1. **Find Slow Queries** (pg_stat_statements)
   - Top queries by mean execution time
   - Queries consuming most total time (calls √ó mean)
2. **Analyze Execution Plans** (EXPLAIN ANALYZE BUFFERS)
   - Identify node types (Seq Scan, Index Scan, etc.)
   - Check buffer hits vs reads
   - Look for temp files (work_mem spills)
3. **Identify Issues**
   - Sequential scans on large tables
   - Row estimate mismatches
   - Missing indexes on joins/filters
   - Expensive function calls
4. **Generate Fixes**
   - Create indexes
   - Update statistics (ANALYZE)
   - Rewrite queries
   - Adjust work_mem
5. **Measure Improvement**
   - Re-run EXPLAIN ANALYZE
   - Compare execution time
   - Verify cache hit ratio improved

### Integration with Existing Tasks

**db-analyze-hotpaths.md** (Find slow queries):
- Enables pg_stat_statements extension
- Queries top 20 slow queries sorted by mean execution time
- Lets user select queries to analyze
- Runs EXPLAIN ANALYZE with BUFFERS on each
- Uses index_advisor extension (Supabase) for recommendations
- Generates performance analysis report markdown
- Identifies common issues: seq scans, row mismatches, buffer misses

**db-explain.md** (Single query analysis):
- Runs EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
- Interprets top-level metrics: planning time, execution time, cost
- Identifies node types: Seq Scan, Index Scan, Nested Loop, etc.
- Analyzes buffers: shared hit (good) vs shared read (bad)
- Detects temp files (work_mem exceeded)
- Common issue detection: missing indexes, stale statistics

**query-optimization.md** (Interactive optimization):
- Finds slow queries from pg_stat_statements
- Runs EXPLAIN ANALYZE
- Identifies issues with clear explanations
- Generates recommendations:
  - Missing indexes with CREATE INDEX statements
  - Stale statistics with ANALYZE commands
  - Query rewrites for better performance
- Creates optimization migration
- Tests optimization (before/after)
- Calculates speedup percentage

**db-rls-audit.md** (RLS performance):
- Lists tables with/without RLS
- Checks RLS policy coverage
- **Critical**: Detects unwrapped auth.uid() in policies
- Recommends wrapping: `(select auth.uid())` for 99.99% performance gain
- PostgreSQL caches SELECT results within statement

### Workflow YAML Structure
```yaml
workflow:
  id: performance-tuning
  name: Performance Tuning
  description: Identify and fix database performance bottlenecks
  version: 1.0

  steps:
    - id: analysis-type
      type: elicit
      question: "Performance analysis type:"
      options:
        - label: "Find slow queries (pg_stat_statements)"
          value: hotpaths
        - label: "Analyze specific query (EXPLAIN)"
          value: explain
        - label: "Interactive optimization session"
          value: optimize
        - label: "Check RLS performance"
          value: rls

    # ========== HOTPATHS ANALYSIS ==========
    - id: run-hotpaths
      type: task
      condition: "{{analysis-type}} == 'hotpaths'"
      task: db-analyze-hotpaths.md

    # ========== EXPLAIN ANALYZE ==========
    - id: query-input
      type: elicit
      condition: "{{analysis-type}} == 'explain'"
      fields:
        - name: sql
          label: "SQL query to analyze"
          type: text
          multiline: true

    - id: run-explain
      type: task
      condition: "{{analysis-type}} == 'explain'"
      task: db-explain.md
      params:
        sql: "{{sql}}"

    # ========== INTERACTIVE OPTIMIZATION ==========
    - id: run-optimize
      type: task
      condition: "{{analysis-type}} == 'optimize'"
      task: query-optimization.md

    # ========== RLS PERFORMANCE ==========
    - id: run-rls-audit
      type: task
      condition: "{{analysis-type}} == 'rls'"
      task: db-rls-audit.md

    - id: rls-recommendations
      type: execute
      condition: "{{analysis-type}} == 'rls'"
      command: |
        echo "=== RLS Performance Recommendations ==="
        echo ""
        echo "‚úÖ FAST: (select auth.uid()) = user_id"
        echo "‚ùå SLOW: auth.uid() = user_id"
        echo ""
        echo "Performance improvement: 99.99% faster (10,000x speedup)"
        echo ""
        echo "Why: PostgreSQL caches SELECT results per statement"
        echo "Without SELECT: auth.uid() called for EVERY row"
        echo "With SELECT: auth.uid() called ONCE per statement"
```

### Performance Targets

**Query Response Time Goals:**
| Query Type | Target | Acceptable | Needs Optimization |
|------------|--------|------------|--------------------|
| Primary key lookup | < 5ms | < 10ms | > 10ms |
| Simple filter (indexed) | < 10ms | < 50ms | > 50ms |
| JOIN (indexed FKs) | < 50ms | < 100ms | > 100ms |
| Aggregation (small dataset) | < 100ms | < 500ms | > 500ms |
| Report query | < 1s | < 5s | > 5s |
| Background job | < 30s | < 5min | > 5min |

**Cache Hit Ratio:**
```sql
-- Overall cache hit ratio (target: > 95%)
SELECT
  sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) AS cache_hit_ratio
FROM pg_statio_user_tables;
```

### Common Performance Issues & Fixes

**Issue 1: Sequential Scan on Large Table**
```
EXPLAIN output:
Seq Scan on posts  (cost=0.00..10000 rows=100000)
  Filter: (user_id = 'xxx')
  Rows Removed by Filter: 99990
```

**Problem**: Scanning entire table to find matching rows
**Impact**: Slow for large tables (> 1000 rows)
**Fix**: Create index on filter column

```sql
CREATE INDEX CONCURRENTLY idx_posts_user_id
  ON posts(user_id)
  WHERE deleted_at IS NULL;
```

**Issue 2: Row Count Mismatch**
```
EXPLAIN output:
Seq Scan on users  (cost=0.00..100 rows=10 actual rows=10000)
```

**Problem**: Estimated 10 rows, actually 10,000 ‚Üí wrong join strategy
**Impact**: Query planner chooses inefficient plan
**Fix**: Update statistics

```sql
ANALYZE users;
-- Or more aggressive:
VACUUM ANALYZE users;
```

**Issue 3: Slow RLS Policy (Unwrapped auth.uid())**
```sql
-- ‚ùå SLOW (auth.uid() called for EVERY row)
CREATE POLICY "posts_policy" ON posts
  FOR ALL TO authenticated
  USING (auth.uid() = user_id);

-- ‚úÖ FAST (auth.uid() called ONCE per statement)
CREATE POLICY "posts_policy" ON posts
  FOR ALL TO authenticated
  USING (
    (select auth.uid()) IS NOT NULL AND
    (select auth.uid()) = user_id
  );
```

**Performance Impact**: **99.99% faster** (10,000x speedup on large tables!)

**Issue 4: Missing Index on JOIN**
```sql
-- Query
SELECT p.*, u.name
FROM posts p
JOIN users u ON p.user_id = u.id;

-- EXPLAIN shows Nested Loop with Seq Scan on posts
```

**Fix**: Index foreign key
```sql
CREATE INDEX CONCURRENTLY idx_posts_user_id ON posts(user_id);
```

**Issue 5: Sort Spilling to Disk**
```
EXPLAIN output:
Sort  (cost=10000..12000 rows=100000)
  Sort Method: external merge  Disk: 50000kB
  Buffers: temp read=6250 written=6250
```

**Problem**: work_mem too small, sorting spills to disk
**Impact**: Much slower than in-memory sort
**Fix**: Increase work_mem OR add index to avoid sort

```sql
-- Option 1: Increase work_mem (session)
SET work_mem = '64MB';

-- Option 2: Index to avoid sort
CREATE INDEX idx_posts_created ON posts(created_at DESC);
```

### Index Recommendation Examples

**Single-Column Index (Simple Filter):**
```sql
-- Query
SELECT * FROM users WHERE email = 'user@example.com';

-- Recommendation
CREATE INDEX CONCURRENTLY idx_users_email ON users(email);
```

**Composite Index (Multiple Filters + ORDER BY):**
```sql
-- Query
SELECT * FROM posts
WHERE user_id = 'xxx' AND status = 'published'
ORDER BY created_at DESC
LIMIT 10;

-- Recommendation
CREATE INDEX CONCURRENTLY idx_posts_user_status_created
  ON posts(user_id, status, created_at DESC)
  WHERE deleted_at IS NULL;
```

**Partial Index (Filtered Queries):**
```sql
-- Query always filters deleted_at IS NULL
SELECT * FROM posts
WHERE user_id = 'xxx' AND deleted_at IS NULL
ORDER BY created_at DESC;

-- Recommendation (smaller, faster)
CREATE INDEX CONCURRENTLY idx_posts_active_user
  ON posts(user_id, created_at DESC)
  WHERE deleted_at IS NULL;
```

**Covering Index (Index-Only Scan):**
```sql
-- Query
SELECT id, title, created_at FROM posts WHERE user_id = 'xxx';

-- Recommendation (includes all selected columns)
CREATE INDEX CONCURRENTLY idx_posts_user_covering
  ON posts(user_id)
  INCLUDE (title, created_at);
-- Result: Index-Only Scan (no table lookup needed!)
```

**Expression Index (Function Calls):**
```sql
-- Query
SELECT * FROM users WHERE LOWER(email) = 'user@example.com';

-- Recommendation
CREATE INDEX CONCURRENTLY idx_users_email_lower
  ON users(LOWER(email));
```

### Before/After Measurement

**Example Output:**
```
‚úÖ OPTIMIZATION COMPLETE

Query: SELECT * FROM posts WHERE user_id = 'xxx' ORDER BY created_at DESC LIMIT 10

Performance Improvement:
  Before:  850ms
  After:   8ms
  Speedup: 106x (99.1% faster)

Changes Applied:
  ‚úì Added index on posts(user_id, created_at DESC)
  ‚úì Wrapped auth.uid() in RLS policy for caching

Migration: supabase/migrations/20241027_optimize_posts.sql

Next Steps:
1. Monitor query performance in production
2. Run ANALYZE posts; periodically to update statistics
3. Review similar queries for same optimization patterns
```

### Error Handling

**Common Performance Analysis Errors:**
```
‚ùå ERROR: extension "pg_stat_statements" is not installed
   ‚Üí Enable extension: CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
   ‚Üí Supabase: Should be enabled by default

‚ùå ERROR: permission denied for function pg_stat_statements
   ‚Üí Use service_role key for admin operations
   ‚Üí Or grant: GRANT EXECUTE ON FUNCTION pg_stat_statements TO user;

‚ùå ERROR: index "idx_name" already exists
   ‚Üí Index already created
   ‚Üí Or drop first: DROP INDEX CONCURRENTLY idx_name;

‚ùå ERROR: cannot explain a query in read-only transaction
   ‚Üí Don't use ANALYZE in read-only mode
   ‚Üí Use: EXPLAIN (without ANALYZE) for plan estimation only
```

### Testing Standards

**Test Location**: `expansion-packs/super-agentes/tests/workflows/`
**Test File**: `performance-tuning-workflow.test.js`

**Test Coverage:**
1. Hotpaths analysis finds slow queries
2. EXPLAIN ANALYZE runs and interprets results
3. Issue identification (seq scan, row mismatch, etc.)
4. Index recommendations generated
5. Optimization migration created
6. Before/after performance measured
7. Speedup calculated correctly
8. RLS performance check detects unwrapped auth.uid()
9. Error handling: pg_stat_statements not enabled

**Mock Requirements:**
- Mock pg_stat_statements queries
- Mock EXPLAIN ANALYZE output
- Mock index_advisor extension
- Mock before/after query execution
- Mock migration file creation

### Next Steps After Completion
1. User runs: `*tune` or `*hotpaths` or `*optimize`
2. Selects analysis type (hotpaths, explain, optimize, RLS)
3. Workflow analyzes performance
4. Issues identified with clear explanations
5. Recommendations generated (indexes, query rewrites)
6. Optimization migration created
7. Performance improvement measured and displayed

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-27 | 1.0 | Initial story creation | @sm (Bob) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

### Review Date: 2025-10-27

### Reviewed By: Quinn (Test Architect)

### Story Quality Assessment

**Status**: Draft (Pre-Implementation Review)

This story demonstrates outstanding performance analysis design and is ready for implementation. Key strengths:
- Modern tooling (pg_stat_statements, index_advisor, auto_explain)
- RLS performance optimization (auth.uid() wrapping = 99.99% speedup!) - CRITICAL
- Comprehensive analysis (hotpaths, EXPLAIN, optimization, measurement)
- Before/after performance measurement for verification
- Index recommendation patterns library
- Well-integrated with 4 existing tasks (db-analyze-hotpaths, db-explain, query-optimization, db-rls-audit)

### Compliance Check

- Coding Standards: ‚úì N/A (Draft story, no code yet)
- Project Structure: ‚úì Follows expansion-packs structure
- Testing Strategy: ‚úì Comprehensive test scenarios with measurement
- All ACs Testable: ‚úì Each AC mapped to test scenarios

### Testability Assessment

**Given-When-Then Mapping**:
- **Given**: User has slow queries or performance issues
- **When**: User runs `*tune`, `*hotpaths`, or `*optimize` workflow
- **Then**: Performance issues identified, recommendations generated, improvements measured

**Test Coverage**: 15 scenarios documented
- 4 happy paths (hotpaths analysis, EXPLAIN, optimization, RLS check)
- 6 issue detection (seq scans, row mismatches, nested loops, buffer misses, temp files, sort spills)
- 5 optimization patterns (single-column index, composite index, partial index, covering index, expression index)

### Critical Security + Performance Finding

üî• **RLS Performance Optimization (AC 7)**:
- Story documents critical performance issue: unwrapped `auth.uid()` in policies
- **Impact**: 99.99% slower (10,000x slowdown on large tables!)
- **Fix**: Wrap in SELECT: `(select auth.uid()) = user_id` for caching
- **Why**: PostgreSQL caches SELECT results per statement
- This is a CRITICAL security + performance best practice for Supabase

### Security Review

‚úì **PASS** - Security design includes performance:
- RLS policy performance check (prevents performance-induced DoS)
- Performance targets specified (interactive < 100ms, reports < 1s)
- pg_stat_statements for production monitoring

### Performance Considerations

‚úì **PASS** - Performance analysis is comprehensive:
- Multiple analysis entry points (hotpaths, EXPLAIN, optimize, RLS)
- Modern tooling (pg_stat_statements, index_advisor)
- Before/after measurement with speedup calculation
- Cache hit ratio monitoring (target > 95%)

### Non-Functional Requirements

- **Security**: ‚úì PASS (RLS performance = security, prevents DoS)
- **Performance**: ‚úì PASS (comprehensive analysis tooling)
- **Reliability**: ‚úì PASS (performance targets, monitoring integration)
- **Maintainability**: ‚úì PASS (optimization patterns library, clear examples)

### Recommendations

**Future Enhancements** (non-blocking):
- Consider query performance regression testing in CI/CD
- Consider automated alerts for queries exceeding performance targets
- Consider performance dashboard (Grafana integration)

### Gate Status

Gate: PASS ‚Üí docs/qa/gates/1.6-performance-tuning-workflow.yml

### Recommended Status

‚úì **Ready for Implementation** - Story is comprehensive and implementation-ready.
(Story owner decides final status)
